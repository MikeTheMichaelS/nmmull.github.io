<!DOCTYPE html>
<html>

<head>
<title>Mini Project 1: Crazy Dice</title>
<link rel="stylesheet" href="../../globalStyle.css">
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body id="course">
<h1>Mini Project 1: Crazy Dice</h1>
<p>In this project, you will be writing a Swift program <code>Crazy-Dice.swift</code> to determine different labelings for sets of dice which behave the same way as the standard labelings (1, 2, and so on up to the number of sides) with respect to their distribution on the sum of the values when rolled. It will be chance to see some more interesting command line input/output, some complexity considerations, an introduction to the idea of iterators.</p>
<h2 id="overview">Overview</h2>
<p>When you roll a pair of standard 6-sided dice, there are a certain number of ways to get values between 2 and 12. For example there is only 1 way to roll a 12, by rolling 6 and 6, and there are 4 ways to roll a 9 (6 and 3, 5 and 4, 4 and 5, 3 and 6, where the first value is corresponds to the first die and the second value corresponds to the second die). The <strong>distribution</strong> of a set of dice can be represented as a dictionary whose keys are numbers that can be rolled and whose values are the number of different ways they can be rolled. For example, a pair of standard 6-sided dice has the following distribution.</p>
<pre class="swift"><code>[2 : 1, 3 : 2, 4 : 3, 5 : 4, 6 : 5, 7 : 6, 8 : 5, 9 : 4, 10 : 3, 11 : 2, 12 : 1]</code></pre>
<p>One 6-sided die with all 1s and one 6-sided with all 2s have the following distribution.</p>
<pre class="swift"><code>[3 : 36]</code></pre>
<p>That is, it is only possible to roll a 3.</p>
<p>It turns out that there is exactly one other pair of dice with positive values on its faces that has the same distribution as a pair of standard 6-sided dice, called the [<a href="https://en.wikipedia.org/wiki/Sicherman_dice">Sicherman dice</a>].</p>
<h2 id="the-details">The Details</h2>
<p>In general, given <span class="math inline">\(n\)</span>, a number of dice, and <span class="math inline">\(k\)</span>, a number of sides per dice, your program should find and display all other sets of <span class="math inline">\(n\)</span> <span class="math inline">\(k\)</span>-sided dice with positive labels (not necessarily distinct) that has the same distribution as the set of <span class="math inline">\(n\)</span> standard <span class="math inline">\(k\)</span>-sided dice (labeled 1 through <span class="math inline">\(k\)</span>). I have included <a href="../Code/Course/Crazy-Dice-Template.swift">[starter-code]</a> which I recommend starting with, though it is not required.</p>
<p>The program should be called in the command line as</p>
<pre><code>$ swift Crazy-Dice.swift [-number=&lt;value&gt;] [-sides=&lt;value&gt;]</code></pre>
<p>The additional arguments are called <em>command line flags</em> and are optional (which is typically denoted by enclosing them in square brackets). These flags can appear in any order</p>
<p>The flag <code>-number=&lt;value&gt;</code> allows you to set the number of dice used in the program to a positive integer <code>&lt;value&gt;</code>. If this flag is not used, then the number of dice used is 2.</p>
<p>The flag <code>-sides=&lt;value&gt;</code> allows you to set the number of sides on each die used in the program to a positive integer <code>&lt;value&gt;</code>. If this flag is not used, then the number of sides used is 6.</p>
<p>The program will iterate through all possible choices of die sets and, if at any point it finds one with the same distribution as the set of standard dice, then it prints</p>
<pre><code>
-----------------
crazy dice found!     
-----------------
die 1: x, x, x,..., x
die 2: x, x, x,..., x
...
die k: x, x, x,..., x
</code></pre>
<p>directly to the command line and continues searching for other instances (the <code>x</code>s and <code>k</code> should obviously be filled in with appropriate values). Note the whitespace above and below the output.</p>
<p>The program should also print the line</p>
<pre><code>approximately x% done...</code></pre>
<p>every time 1 percent more of the possible checks have been completed. See below for more details on how to do this.</p>
<p>You do not have to handle sets of dices with different numbers of sides (e.g., you don't need to consider a set with a 6-sided die and a 7-sided die) and the new sets will always have the same number of dice with the same number of sides, only different positive labels.</p>
<h3 id="part-1-command-line-arguments">Part 1: Command Line Arguments</h3>
<p>The first step to completing this program is use handle the command line flags. In order to get arguments from the command line, Swift has an array of <code>String</code>s available to you called <code>CommandLine.arguments</code>. The first element is always the name of the file, in this case <code>Crazy-Dice.swift</code>. The starter code contains the part of the code which gets elements from this Array. You need to fill in the function <code>readArg(_:)</code> which will read the <code>String</code> corresponding to a flag and, if it is well-formed, grab the value and set the variables <code>numberOfSides</code> and <code>numberOfDice</code> accordingly.</p>
<p>In any case that the flags are not well-formed (e.g., they are misspelled or contain spaces or the value is negative), then your code should call the <code>printUsage()</code> function, which prints the information about how to use the program and exits the program. This is a standard practice.</p>
<h3 id="part-2-iterators">Part 2: Iterators</h3>
<p>The most difficult part of this project is going to be iterating over complex objects, like possible die sets. In order to do this, you will use a simple version of an <em>iterator</em>. Generally speaking, an iterator is just a function that gets you the next element in a sequence, given the last element you saw. This allows you to iterate over things that are more complicated than lists or too numerous to reasonable store in a list before iterating. An iterator consists of a function for getting the <em>first</em> element of a sequence, and a function for getting the <em>next</em> element of a sequence, after a given element. The next function returns an optional and, in particular, returns <code>nil</code> on the last element of the sequence. You can see the usage of the die set iterator functions in the <code>while-let</code> loop of the body of <code>printCrazyDice()</code>. Iterators are far more general than we are treating them here, and we will hopefully see some of the more powerful uses at the end of the course.</p>
<p>There are three kinds of iterators that you will need for this project: one for a <code>Die</code>, a <code>DieSet</code>, and a <code>Roll</code>. In the starter code, we are using a new tool called <em>type aliasing</em>. The line</p>
<pre class="swift"><code>typealias &lt;name&gt; = &lt;type&gt;</code></pre>
<p>allows you to use <code>&lt;name&gt;</code> in place of <code>&lt;type&gt;</code> in your code. The purpose of this is readability, to make the intent of code more clear. It does not change the meaning of the type, it is just a replacement, you could replace <code>Die</code> with <code>[Int]</code> everywhere and the code would behave identically.</p>
<p>A <code>Die</code> is represented by an Array of Integers. To make the representation unique, we will maintain that a <code>Die</code> is <strong>sorted in decreasing order</strong>. This means <code>[6, 5, 4, 3, 2, 1]</code> is the only representation of a standard 6-sided die, whereas <code>[1, 5, 2, 4, 3, 6]</code> is not a representation. For the <code>Die</code> iterator, the first <code>Die</code> is the one with the minimum side value on all faces. The next <code>Die</code> is the one that is next [<a href="https://en.wikipedia.org/wiki/Lexicographical_order">lexicographically</a>] (lexicographic order is basically the same as alphabetical order). Here are a couple assert tests to show a bit of the pattern. I recommend trying to write a couple of your own just to test your understanding.</p>
<pre class="swift"><code>assert(nextDie(after: [1, 1, 1, 1], minSide: 1, maxSide: 3) == [2, 1, 1, 1])
assert(nextDie(after: [2, 1, 1, 1], minSide: 1, maxSide: 3) == [2, 2, 1, 1])
assert(nextDie(after: [2, 2, 1, 1], minSide: 1, maxSide: 3) == [2, 2, 2, 1])
assert(nextDie(after: [2, 2, 2, 1], minSide: 1, maxSide: 3) == [2, 2, 2, 2])
assert(nextDie(after: [2, 2, 2, 2], minSide: 1, maxSide: 3) == [3, 1, 1, 1])
assert(nextDie(after: [3, 3, 3, 3], minSide: 1, maxSide: 3) == nil)</code></pre>
<p>A <code>DieSet</code> is represented as by an Array of <code>Die</code>s. Again, you are going to want to treat these as sorted in decreasing order, except the sorted with respect to <em>the lexicographic order of dice</em>. This is a bit complicated, but the point of saying it this way is to make clear that the code will look a lot like the code for <code>Die</code>. The clearer way of saying it is that we only want to check one order of the <code>Die</code>s in a <code>DieSet</code>, as reorderings don't change the set or the distribution.</p>
<p>The last iterator is for <code>Rolls</code> which are also represented arrays of <code>Int</code>s. We imagine that a <code>Roll</code> is a set of indices, one for each <code>Die</code> in a <code>DieSet</code>, so the <code>Roll</code> <code>[1, 2]</code>, for the <code>DieSet</code> <code>[[4, 3, 1], [5, 2, 1]]</code> corresponds to rolling a <code>3</code> and a <code>1</code>. The function <code>rollValue(ofDieSet:, onRoll:)</code> then takes the sum of these values, returning the value <code>4</code>. The iterator for this will look different than the previous two. The <code>Roll</code> <code>[1, 2]</code> is distinct from <code>[2, 1]</code>, since they correspond to different faces on different dice.</p>
<pre class="swift"><code>assert(rollValue(ofDieSet: [[4, 3, 2, 1], [4, 3, 2, 1]], onRoll:[0, 0]) == 8)
assert(rollValue(ofDieSet: [[4, 3, 2, 1], [4, 3, 2, 1]], onRoll:[0, 2]) == 6) </code></pre>
<h3 id="part-3-finding-crazy-dice">Part 3: Finding Crazy Dice</h3>
<p>You then have to fill in the function <code>distribution(ofDieSet:)</code>, which finds the distribution of a <code>DieSet</code>, and use it in the <code>printCrazyDice</code> function to determine if any of the <code>DieSet</code>s you iterate over are crazy dice, i.e., have the same distribution as <code>standardDistribution</code>.</p>
<h3 id="part-4-printing-percentage-completion">Part 4: Printing Percentage Completion</h3>
<p>Since this program will take a long time on some inputs, it might be useful to print to the terminal some message about the progress being made. In order to do this, we need to know how many <code>DieSets</code> we have to check. A <code>DieSet</code> is a <em>multiset</em>, which is an unordered collection of objects that may repeat. The formula for the number of objects in multiset is <span class="math display">\[
\binom{n + k - 1}{k}
\]</span> where <span class="math inline">\(n\)</span> is the number of elements we are choosing from and <span class="math inline">\(k\)</span> is the size of the multiset. In this case, <span class="math inline">\(n\)</span> is the number of possible <code>Die</code>s and <code>k</code> is the number of <code>Die</code>s we use. You should use this formula to calculate the number of possible checks that have to be done (<em>hint.</em> a <code>Die</code> is also a multiset of <code>Int</code>s instead of <code>Die</code>s). You should use this make sure that the percentage done gets printed at the rights times.</p>
<p>You might have noticed that we are using approximations and <code>Double</code>s here. This is because the numbers we are working with are <em>really</em> big, too big to compute the factorial in the standard way. You should try this yourself, and come up with a definition of <code>approxChoose(_:, _:)</code> which keeps the numbers small(ish) throughout the procedure (i.e., multiply fractions rather than factorials).</p>
<h3 id="part-5-testing">Part 5: Testing</h3>
<p>Use your program to determine the crazy dice (if any) for two 4-sided dice, two 5-sided dice, and two 6-sided dice (this last one is just verifying the Sicherman dice, and will take a while, so feel free to stop it once it has found the Sicherman dice). Also determine the crazy dice (if any) for the three 3-sided dice.</p>
<h3 id="part-6-optimization-extra-credit">Part 6: Optimization (Extra Credit)</h3>
<p>There are a ton of optimizations that can be made to make this code faster by removing unnecessary cases to check. For extra credit, you can try to implement some for the case of two dice. There is a separate part in the code where you can include your implementation. You may have to change other parts of the code as well. You are not required to give percentage updates for this case since it will be harder to gauge how many checks you are actually doing. See how high you can get the side-count while keeping the running time under two minutes. A couple ideas for optimizations:</p>
<ul>
<li>You know from the start that every die must have exactly one 1-face. This is because there is only one way to get the value 2, with two 1's.</li>
<li>In a similar vein, there cannot be duplicates of the largest value on a single die because the largest value necessarily contributes to the largest sum, and there is only one way to achieve the largest sum in the case of standard dice.</li>
<li>The maximum side value is set to <code>numberOfDice * numberOfSides - 2</code>, where the <code>2</code> comes from the observation that some die must have both a 1 and a 2. This can be decreased dramatically, by thinking through the logic of the largest value. Take the case of 6-sided dice, we know there can be no 10, because, since the maximum value is 12, the other dice would have to have only 1's and 2's. But this would give too many ways to get 2 or 3.</li>
<li>When the largest value on any one die is given, the largest value one the other die is restricted. In the case of 6-sided dice, if one die has an 8 on it, then the other can have at most a 4.</li>
</ul>
<p>If you are feeling super adventurous, see what you can do with optimizing for more dice. Try to find the crazy dice for three 4-sided dice. This is not extra-credit, but something fun to think about.</p>
<h2 id="submission">Submission</h2>
<p>This project is due <strong>Wednesday, July 15 by 6PM</strong>. Submit your version of <code>Crazy-Dice.swift</code> and include the information required in Part 5 either very clearly as comments in your code or as text input directly into Canvas.</p>
</body>

</html>
