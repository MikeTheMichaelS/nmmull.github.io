<!DOCTYPE html>
<html>

<head>
<title>Protocols and Type Constraints</title>
<link rel="stylesheet" href="../../globalStyle.css">
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body id="course">
<h1>Protocols and Type Constraints</h1>
<p>When we defined generic functions and structures, we had to be careful that we assumed <em>nothing</em> about the type variables that we used. This proved to be powerful in many cases. We could write one generic function and get a function for any consistent assignment of the type variables for free.</p>
<p><em>Example.</em> The problem of <em>sorting</em> is the problem of rearranging an array so that it's elements appear in increasing order. This is a Swift implementation of a method for sorting called <em>insertion sort</em>. It works by first sorting the entire array except for the first element, and then inserting the first element into the sorted list in the correct place.</p>
<pre class="swift"><code>func insertionSort&lt;T&gt;(_ l: [T], by lte: (T, T) -&gt; Bool) -&gt; [T] {
    if l.isEmpty { return [] }
    var almostSorted = insertionSort(Array(l[1...]), by: lte)
    for i in almostSorted.indices {
        if lte(l[0], almostSorted[i]) {
            almostSorted.insert(l[0], at: i)
            return almostSorted
        }
    }
    almostSorted.append(l[0])
    return almostSorted
}

assert(insertionSort(Array(1...100).shuffled(), by: &lt;=) == Array(1...100))</code></pre>
<h2 id="type-constraints">Type Constraints</h2>
<p>Because the definition of <code>insertionSort(_:, by:)</code> has to be agnostic about the type variable <code>T</code>, we have to pass in the comparing function <code>lte(_:, _:)</code> as an argument, making this a higher-order function. This is not so bad, and in some cases could be very useful. We can use this function to sort an array of elements in <em>decreasing</em> order just by passing in <code>&gt;=</code> instead of <code>&lt;=</code>. But it would also be nice if we could write this function so that it is <em>kind of</em> generic, so that we could assume just enough about <code>T</code> to know that we can compare its elements.</p>
<p>The way we specify that we want to assume <em>a little</em> about the type <code>T</code> is by using <em>type constraints</em>.</p>
<pre class="swift"><code>func insertionSort&lt;T: Comparable&gt;(_ l: [T]) -&gt; [T] {
    if l.isEmpty { return [] }
    var almostSorted = insertionSort(Array(l[1...]))
    for i in almostSorted.indices {
        if l[0] &lt;= almostSorted[i] {
            almostSorted.insert(l[0], at: i)
            return almostSorted
        }
    }
    almostSorted.append(l[0])
    return almostSorted
}</code></pre>
<p>The type <code>T</code> is constrained to be <code>Comparable</code>, which allows us to the function <code>&lt;=</code> in the body of the function. Cleaning up the body of the function.</p>
<p><em>Note.</em> In practice we would probably see this implemented as</p>
<pre class="swift"><code>func insertionSort&lt;T: Comparable&gt;(_ l: [T]) -&gt; [T] {
    return insertionSort(l, by: &lt;=)
}</code></pre>
<p>There is no need to rewrite code, and the first version is handy to have around. The <code>Array&lt;T&gt;</code> type in Swift has a both a method <code>.sort(by:)</code> and a method <code>sort()</code> which is available when <code>T</code> is comparable.</p>
<h2 id="protocols">Protocols</h2>
<p>The object <code>Comparable</code> in the above example is called a <em>protocol</em>. A protocol is a general description of some sort of functionality, like comparability, and is made up of a collection of property and method signatures (just names and types, no implementations). For a type to a <em>conform</em> to a protocol, it must implement these methods.</p>
<p>To express in Swift that a structure conforms to a protocol, we include the protocol name in the after the structure name, preceded by a colon. If we want to implement multiple protocols, they all included separated by commas. Within the definition of the struct the properties and methods required by each protocol must be implemented.</p>
<p><em>Example.</em> The <code>CustomStringConvertible</code> protocol allows you to specify how an object should be printed or used in <code>String</code> interpolation. It has one computed property, <code>description: String</code>, which outputs the <code>String</code> form of the object.</p>
<pre class="swift"><code>struct Point {
    var xCoordinate: Double
    var yCoordinate: Double
}

print(Point(xCoordinate: 1.2, yCoordinate: 4.5))
// prints:
// Point(xCoordinate: 1.2, yCoordinate: 4.5)</code></pre>
<pre class="swift"><code>struct Point: CustomStringConvertible {
    var xCoordinate: Double
    var yCoordinate: Double

    var description: String {
        return &quot;&lt;\(xCoordinate), \(yCoordinate)&gt;&quot;
    }
}

print(Point(xCoordinate: 1.2, yCoordinate: 4.5))
// prints:
// &lt;1.2, 4.5&gt;</code></pre>
<h3 id="an-aside-on-type-properties-and-methods">An Aside on Type Properties and Methods</h3>
<p>In the notes on structures, we considered only properties and methods that were dependent on individual instances of a given type. It is also possible to define properties and methods for the type itself. These are called <em>type properties (methods)</em> or <em>static properties (methods)</em>. They are accessed using dot notation on the type name, e.g., <code>TypeName.property</code>. Not surprisingly, we have already been using type properties, <code>Double.pi</code> is a <code>Double</code> which is associated with the type <code>Double</code> and not any particular <code>Double</code>. The reason this comes up now is that the operators like <code>&lt;=</code> and <code>==</code> are actually static methods of particular types, and originate inside protocols. Generally speaking, type properties are not common, but it is useful to know about them if you might need them.</p>
<p><em>Example.</em> We we want to make our <code>Point</code>s equatable, we can make <code>Point</code> conform to the <code>Equatable</code> protocol as well. This requires writing the static method <code>==</code> for equality.</p>
<pre class="swift"><code>struct Point: CustomStringConvertible, Equatable {
    var xCoordinate: Double
    var yCoordinate: Double

    var description: String {
        return &quot;&lt;\(xCoordinate), \(yCoordinate)&gt;&quot;
    }

    static func == (lhs: Point, rhs: Point) -&gt; Bool {
        return lhs.xCoordinate == rhs.xCoordinate &amp;&amp;
               lhs.yCoordinate == rhs.yCoordinate
    }
}
</code></pre>
<p>If you take a look at the<code>Equatable</code> protocol in the documentation, you will see that <code>!=</code> is also a type method for this protocol. We did not have to implement it above because <code>!=</code> has a <em>default implementation</em>, <code>x != y</code> is computed as <code>!(x == y)</code> by default. This is where we see the real strength of protocols. There is usually a small minimal collection of properties and methods that have to be implemented, on which all other default implementations depend. So we get a bunch of properties and methods for free (in addition to those functions defined using type constraints!) usually without much work.</p>
<p>The use of protocols in fundamental in Swift, to the extend that programming in Swift is sometimes referred to as <em>protocol-driven programming.</em> This idea is taken from functional programming in which it is also fundamental, but goes by a different name. Protocols allow us to write functions as abstractly as possible without resorting to higher order function, like we did with the sorting example above. This is why arrays, dictionaries, <code>String</code>s and any other type in Swift that looks like a collection of objects have similar properties and methods like <code>count</code> and <code>removeFirst()</code>, they all conform to a protocol <code>Collection</code>.</p>
<p>Protocols can also be used to represent common programming patterns. We won't go over this, but if you are interested see the Swift book section on [<a href="https://docs.swift.org/swift-book/LanguageGuide/Protocols.html#ID276">Delegation</a>].</p>
<h2 id="iterators">Iterators</h2>
<p>Using protocols, we can write more natural looking iterators than we did in the first project. The two protocols we need are <code>IteratorProtocol</code> and <code>Sequence</code>. The first, not so surprisingly requires a function called <code>next()</code> which gets the next element. The second allows the type to be used in <code>for</code> loops and requires a function called <code>makeIterator()</code> which creates an iterator for the type. When implemented together, <code>next()</code> is the only required function. This is an example in which default implements might depend on multiple protocols. Specifically, if a type conforms to <code>Sequence</code> and <code>IteratorProtocol</code>, then the default implementation of <code>makeIterator()</code> is to return <code>self</code>, which is already an iterator.</p>
<pre class="swift"><code>struct StandardDiceRolls: Sequence, IteratorProtocol {
    let numberOfDice: Int
    var roll: [Int]

    init(numberOfDice: Int) {
        self.numberOfDice = numberOfDice
        roll = [0] + [Int](repeating: 1, count: numberOfDice - 1)
    }

    mutating func next() -&gt; [Int]? {
        var index = 0
        while index &lt; numberOfDice, roll[index] == 6 {
            roll[index] = 1
            index += 1
        }
        if index == numberOfDice { return nil }
        roll[index] += 1
        return roll
    }
}

for roll in StandardDiceRolls(numberOfDice: 3) {
    print(roll)
}</code></pre>
<h2 id="extensions">Extensions</h2>
<p>It is not uncommon to have a type that conforms to a large number of protocols (Arrays in Swift conform to to 18). Including all the protocols to which a type conforms within its declaration is not practical, it creates too much clutter and obfuscates the more important aspects of its definition. It is more common to implement protocol conformation as <em>extensions</em>.</p>
<p>Extensions are a general tool for adding computed properties and methods to a preexisting types. The syntax looks just like the syntax for structures except with a different keyword <code>extension</code>.</p>
<pre class="swift"><code>extension Int {
    isEven: Bool {
        get {
            return self % 2 == 0
        }
    }
    
    isOdd: Bool {
        get {
            return !isEven
        }
    }
}</code></pre>
<p>This extension allows us to write <code>x.isEven</code> in place of <code>x % 2 == 0</code>. Like many things we've seen so far, extensions exists simply to make the organization of our code more understandable. We can move methods that are not core to a given structure into an extension.</p>
<p>In order to conform to a protocol, we include the protocol name just as we did for structures.</p>
<pre class="swift"><code>struct Point {
    var xCoordinate: Double
    var yCoordinate: Double
}

extension Point: CustomStringConvertible {
    var description: String {
        return &quot;&lt;\(xCoordinate), \(yCoordinate)&gt;&quot;
    }
}</code></pre>
<p>Now our definition of <code>Point</code> is simple again, and we can clearly see what we have done to conform to the <code>CustomStringConvertible</code> protocol.</p>
<p>One final note about extensions, when extending a generic type, the type variables are inherited and do not need to be specified again. So if you want to extend a built-in type you have to look to the documentation to see what the type variable name is (for arrays, its <code>Element</code>).</p>
<pre class="swift"><code>extension Array {
    var second: Element {
        get {
            return self[1]
        }
    }
}</code></pre>
</body>

</html>
