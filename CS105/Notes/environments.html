<!DOCTYPE html>
<html>

<head>
<title>Environments</title>
<link rel="stylesheet" href="../../globalStyle.css">
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body id="course">
<h1>Environments</h1>
<p>Up to now, we have said that the lines of a Swift program <em>change the state</em> of the program, and we have had to use our intuition a bit to reason about what exactly that state is. Fortunately, things like <code>if</code>-statements and function declarations have (somewhat) clear interpretations as concepts in natural language and general logical reasoning, so we have been able to get by up to this point. But as we are starting to see more complicated examples, and things like captured values or escaping functions, we are going to want a more robust model of execution in our minds so that we know what behavior to expect from the programs that we write.</p>
<p>For URM programs, the model of execution consisted of a URM and a way of maintaining the next instruction to be executed in the program. Part of the reason that we started with URMs is because it is possible to see both the language and model in one sitting. Swift is, of course, more complicated, we instead maintain an <em>environment</em>.</p>
<p>We will use <em>environment diagrams</em> to visualize environments for the execution of a Swift program. These were first successfully used as pedagogical tools to describe the behavior of imperative programs by Harold Abelson and Gerald J. Sussman (with Julie Sussman) in <em>Structure and Interpretation of Computer Programs</em>, an introductory programming textbook that, despite being a couple decades olds at this point, is still quite useful and entertaining. They used a version of the language Scheme. Incidentally, my first programming course borrowed much of its material from SICP and adapted environment diagrams for the language Python. I am continuing this tradition, now for Swift.</p>
<p>Environment diagrams have a history at my alma mater of being disliked (or hated) by students. This seems to me primarily because some people already have intuitions about the way programs are executed, and feel like they don't need a complicated formal description. I personally like environment diagrams quite a bit, in part because of my interest in logic. They allow us to give a complete logical description of how a program is executed, and they give a glimpse of how you might write an interpreter or compiler for a more complicated language like Swift.</p>
<p>In what follows, we will describe environment diagrams formally for a subset of features of Swift. It is not too difficult to extend the notion to more complicated features, but it is enough for us now to look at the basics. We also make a couple simplifying assumptions:</p>
<ul>
<li>Functions are always called after their declarations.</li>
<li>Inner and outer names of inputs are always the same and always given.</li>
<li>Programs do not include unnamed closures.</li>
</ul>
<h2 id="frames">Frames</h2>
<p>An environment is made up of a list of <em>frames</em>, each of which consists of a collection of name-value pairs called <em>bindings</em>. The names may be constant names, variable names, or function names, and are bound to values throughout the execution of a program. A frame is visualized as a box with a title and a vertical separating line, where names appear to the left of the line and values appear to the right.</p>
<p><img src="../Other/Environment-Images/basic-frame.png" style="zoom:20%;" /></p>
<p>When starting to execute a program, there is a single frame in the environment, the <em>global frame</em>, which will, over the execution of the program, contain all variables and functions at the top-level of the program, those not defined inside other function declarations.</p>
<p><img src="../Other/Environment-Images/global-frame.png" style="zoom:20%;" /></p>
<p>New frames will be created by calls to defined functions and control-flow statements, and will be given different titles according to each case. These represent the local environments in which work is performed, isolating variables defined inside a function or control-flow statement from outside the body of the function or statement. They will be placed below the global frame in a list from top to bottom as they are created. Each new frame also has a <em>parent frame</em>.</p>
<blockquote>
<p>The <strong>parent frame of a function call</strong> is the frame in which the function is declared. The <strong>parent frame of a control-flow statement</strong> is the frame in which the statement is executed.</p>
</blockquote>
<p>Frames are numbered according to their position in the list. The global frame has number 0. Parents will either be referred by number, or by name if it is clear from context (e.g., if the parent is the global frame).</p>
<p>To give a sense of how this will look, the following is the state of the environment diagram after executing the following program.</p>
<pre class="swift"><code>func f(x: Int) -&gt; Int {
    return x + 2
}
f(x: 3)</code></pre>
<p><img src="../Other/Environment-Images/simple-example.png" style="zoom:30%;" /></p>
<p>The name <code>f</code> appears in the global frame and a new frame was created when the function was called.</p>
<h2 id="executing-programs">Executing Programs</h2>
<p>In the notes on Program Anatomy, we saw that a Swift program is an ordered collection of statements. In the environment, every frame corresponds to a collections of statements that will be executed in order from top to bottom. This might seem quite different from the model of execution for URM programs, where the next statement depended on the execution of the current statement (as for jump instructions). However, because of compound statements, individual statements can cause the creation of new frames, which will run their own collection of statements. This is where we get the sense of looping and jumping around in a Swift program even though we are reading statements in a fixed order.</p>
<p>Once a function or control statement is finished executing, there are no more statements to execute, the new frame is labeled with DONE, as in the previous example. In the execution of a program, because of nested statements, there may be many <em>live</em> frames at any one time. Therefore, we also keep track of a <em>current frame</em>. Fortunately, we don't have to actually do anything special to maintain the current frame.</p>
<blockquote>
<p>The <strong>current frame</strong> is the frame which has the largest number and is not labeled with DONE.</p>
</blockquote>
<h2 id="evaluating-expressions">Evaluating Expressions</h2>
<p>Evaluating expressions is done with respect to the state of an environment diagram. We will need to evaluate expressions to execute certain statements. We can update the rules from the notes on Program Anatomy to reflect this.</p>
<ul>
<li><p>The value of a literal is the literal itself (the expression <code>2</code> evaluates to <code>2</code> no matter the environment diagram)</p></li>
<li><p>The value of a name (a variable, constant, or function name) is determined by <em>lookup</em>.</p>
<blockquote>
<p><strong>Lookup Procedure.</strong> If the name is in the current frame, then the value is the one corresponding to that name. If not, then the same check is done in the parent frame. If it is not in the parent frame, then this is repeated in the parent's parent frame, and so on. If this is done all the way to the global frame and the name does not appear, then the expression has no value and the program fails to execute.</p>
</blockquote></li>
<li><p>Given an expression of the form <code>expF(name1: exp1,..., namek: expK)</code>. Apply the this evaluation procedure to <code>expF</code> to get the value of <code>valueF</code> of <code>expF</code>. If <code>valueF</code> is a declared function, then <strong>create a new frame</strong> with the name of <code>valueF</code> (we are ignoring closures for now, so <code>valueF</code> must have a name) as its title. For each input, from left to right, evaluate the expression <code>inputJ</code> to get its value <code>valueJ</code> and bind it to the name <code>nameJ</code>. Once this is done, execute the statements in the body of the function from top to bottom.</p></li>
</ul>
<p>Note the circularity here. We need to know how to execute statements to evaluate expressions, but we need to know how to evaluate expressions to execute some statements! Also note that we have been a bit ambiguous about built in functions and operators. For these, we <strong>do not</strong> create new frames. We will treat their application as being understood to have the behavior we expect them to have. This is a bit of a punt, but it makes sense because we don't actually have access to the code that make ups built-in functions, and so their application should not be expressed in the environment.</p>
<h2 id="executing-statements">Executing Statements</h2>
<p>We now describe how to execute statements and, in particular, how the environment is affected by the execution of certain statements. They will be presented somewhat tersely. The next section contains an extended example.</p>
<h3 id="expressions">Expressions</h3>
<p>Given a statement which is just an (non-function) expression, the expression is simply evaluated in the environment.</p>
<h3 id="function-declarations">Function Declarations</h3>
<pre><code>func &lt;funcName&gt;(&lt;inputs&gt;) {
    &lt;body&gt;
}</code></pre>
<p>The name <code>&lt;funcName&gt;</code> is bound to an arrow point <em>out of</em> the location where the value should be to a <em>function object</em>, represented in the diagram simply as "function: <code>&lt;funcName&gt;</code>". We can think of this as a copy (or, more formally, a closure) of the statements in <code>&lt;body&gt;</code>.</p>
<p><img src="../Other/Environment-Images/func-example.png" style="zoom:20%;" /></p>
<h3 id="variable-and-constant-declarations">Variable and Constant Declarations</h3>
<pre class="swift"><code>var &lt;name&gt; = &lt;expression&gt;</code></pre>
<p>or</p>
<pre><code>let &lt;name&gt; = &lt;expression&gt;</code></pre>
<p>If the expression <code>&lt;expression&gt;</code> not a variable, then it is evaluated and its value bound to the name <code>&lt;name&gt;</code> in the current frame. If <code>&lt;expression&gt;</code> is a variable <code>someVariable</code>, then there are two possible behaviors. If the value of <code>someVariable</code> is an arrow, like in the case of functions, the <code>&lt;name&gt;</code> is bound to <strong>an arrow pointing to the same object</strong>. Otherwise, it is value is bound directly to <code>&lt;name&gt;</code> in the current frame. This is the difference between a value type and a reference type.</p>
<blockquote>
<p>A <strong>value type</strong> is <em>copied</em> when it is the object of an assignment. The <em>reference</em> (the arrow) of a <strong>reference type</strong> is copied when it is the object of an assignment.</p>
</blockquote>
<p>Take, for example, the program</p>
<pre class="swift"><code>func f() -&gt; Int {
    return 0
}
var g = f
var y = [1, 2, 3, 4]
var z = y
z.append(5)</code></pre>
<p>with the following environment diagram at the end of execution.</p>
<p><img src="../Other/Environment-Images/ref-vs-val.png" style="zoom:20%;" /></p>
<h3 id="assignments">Assignments</h3>
<pre class="swift"><code>&lt;name&gt; = &lt;expression&gt;</code></pre>
<p>The name <code>&lt;name&gt;</code> is found in the environment using the lookup procedure from above. If the name is found, then then expression is evaluated and the value is bound to the name in the environment, replacing the old value. The same fact about value types and reference types apply here as well.</p>
<h3 id="while-statements"><code>while</code> Statements</h3>
<pre><code>while &lt;condition&gt; {
    &lt;body&gt;
}</code></pre>
<p>The expression <code>&lt;condition&gt;</code> is evaluated in the environment diagram. If its value is <code>true</code>, then a new frame with the title WHILE is created which executes the statements in <code>&lt;body&gt;</code> from top to bottom. Once this frame as completed executing (once it is labeled DONE), then the expression <code>&lt;condition&gt;</code> is evaluated again. If its value is <code>true</code> again, then a new frame is created executes <code>&lt;body&gt;</code>. This is repeated as long as the value of <code>&lt;condition&gt;</code> evaluates to <code>true</code>.</p>
<p>The semantics for <code>for</code> loops would be similar, but we won't consider them for now.</p>
<h3 id="if-statements"><code>if</code> Statements</h3>
<pre><code>if &lt;condition&gt; {
    &lt;body&gt;
}</code></pre>
<p>The expression <code>&lt;condition&gt;</code> is evaluated in the environment diagram. If its value is <code>true</code>, then a new frame titled IF is created which executes the statements in <code>&lt;body&gt;</code> from top to bottom. It is not too hard to imagine how to adapt this for <code>else if</code> and <code>else</code> as well.</p>
<h3 id="return-statements"><code>return</code> Statements</h3>
<pre><code>return &lt;expression&gt;</code></pre>
<p>the expression <code>&lt;expression&gt;</code> is first evaluated to some value <code>someValue</code>. The current frame is then labeled DONE and all subsequent statements of the frame are ignored. If the current frame corresponds to a function call, then and a special name <code>RETURN</code> is bound to <code>someValue</code> in the current frame. If the current frame is does not correspond to a function call, then the parent frame is checked. The parent frame is labeled DONE and RETURN is bound to <code>someValue</code>, with subsequent statements ignored. This is repeated for the parent's parent, and so on, until a function calling frame is reached.</p>
<p>One special case here is for functions without return values. Once a frame for a function call with no return value is completed, we always bind RETURN to <code>()</code> in the frame.</p>
<h3 id="an-example">An Example</h3>
<p>We will go over the steps of maintaining an environment diagram for the following program. The statements will be labeled by the number in each frame.</p>
<pre><code>var x = 2                      | 0 &lt;---
                               |
func f(y: Int) -&gt; Int {        | 1
    return x + 2               |
}                              |
                               |
func g(x: Int) -&gt; Int {        | 2
    if x == 3 {                |
        let z = 3              |
        return z + 4           |
    }                          |
    return x + 10              |
}                              |
                               |
func h() {                     | 3
    print(f(y: x) + g(x: 3))   |
}                              |
                               |
let z = h()                    | 4</code></pre>
<p><img src="../Other/Environment-Images/global-frame.png" style="zoom:20%;" /></p>
<ol type="1">
<li><p>Statement 0 is a variable declaration. We first have to evaluate the object of the declaration. This is just the literal <code>2</code>, which has value <code>2</code>. We then bind the name <code>x</code> to the value <code>2</code> in the global frame.</p></li>
<li><p>Statement 1 is a function declaration. We bind the name <code>f</code> to a reference (arrow) to a function object.</p></li>
<li><p>Statements 2 and 3 are also function declarations and bind name to references in the global frame.</p></li>
</ol>
<pre><code>var x = 2                      | 0
                               |
func f(y: Int) -&gt; Int {        | 1
    return x + 2               |
}                              |
                               |
func g(x: Int) -&gt; Int {        | 2
    if x == 3 {                |
        let z = 3              |
        return z + 4           |
    }                          |
    return x + 10              |
}                              |
                               |
func h() {                     | 3
    print(f(y: x) + g(x: 3))   |
}                              |
                               |
let z = h()                    | 4 &lt;---</code></pre>
<p><img src="../Other/Environment-Images/example-1.png" style="zoom:20%;" /></p>
<ol start="4" type="1">
<li>Statement 4 is a constant declaration. First we have to evaluate the object of the declaration. This starts with evaluating <code>h</code> which yields the value <code>h</code> by lookup in the global frame. Since this is a defined function, we create a new frame. And since <code>h</code> has no inputs we don't initialize any bindings in the frame.</li>
</ol>
<pre><code>var x = 2                      | 0      |
                               |        |
func f(y: Int) -&gt; Int {        | 1      |
    return x + 2               |        |
}                              |        |
                               | 2      |
func g(x: Int) -&gt; Int {        |        |
    if x == 3 {                | 3      |
        let z = 3              |        |
        return z + 4           |        |
    }                          |        |
    return x + 10              |        |
}                              |        |
                               |        |
func h() {                     | 4      |
    print(f(y: x) + g(x: x))   |        | 0 &lt;---
}                              |        |
                               |        |
let z = h()                    | 5 &lt;--- |</code></pre>
<p><img src="../Other/Environment-Images/example-2.png" style="zoom:33%;" /></p>
<ol start="5" type="1">
<li><p>The next statement to execute is the first statement for the new frame, Statement 0 in <code>h</code>. It is a function call, so we first evalute <code>print</code>, which we find is a built-in function. We don't make new frames for built-in functions, so next we evaluate the input to <code>print</code>. Again, we won't make a new frame for the call to the operator <code>+</code>, so next we evaluate its inputs, first <code>f(y: x)</code>, then <code>g(x: 3)</code>.</p></li>
<li><p>To evaluate <code>f(y: x)</code>, we first evaluate <code>f</code>, which yields the function <code>f</code> in the global frame by the lookup procedure. Note that <code>f</code> is not in the current frame, so this required checking the parent frame. Since <code>f</code> is a defined function, we create a new frame. The parent of this frame is the global frame, where <code>f</code> is declared, not the current frame, where <code>f</code> is called. We then evaluate the input <code>x</code>, and bind its value <code>2</code> to the name <code>y</code> in the new frame.</p></li>
</ol>
<pre><code>var x = 2                      | 0      |        |
                               |        |        |
func f(y: Int) -&gt; Int {        | 1      |        |
    return x + 2               |        |        | 0 &lt;---
}                              |        |        |
                               |        |        |
func g(x: Int) -&gt; Int {        | 2      |        |
    if x == 3 {                |        |        |
        let z = 3              |        |        |
        return z + 4           |        |        |
    }                          |        |        |
    return x + 10              |        |        |
}                              |        |        |
                               |        |        |
func h() {                     | 3      |        |
    print(f(y: x) + g(x: 3))   |        | 0 &lt;--- |
}                              |        |        |
                               |        |        |
let z = h()                    | 4 &lt;--- |        |</code></pre>
<p><img src="../Other/Environment-Images/example-3.png" style="zoom:30%;" /></p>
<ol start="7" type="1">
<li><p>Statement 0 in <code>f</code> is a return statement. We first evaluate the expression <code>x + 2</code>, for which <code>x</code> evaluates to <code>2</code> by lookup in the parent frame, all together yielding the value <code>4</code>. We create the special RETURN binding. Since there are no more lines for this frame to execute, we label the frame with DONE.</p></li>
<li><p>Evaluating <code>g(x: 3)</code> is roughly the same to begin. Since <code>g</code> is a defined function, we create a new frame and bind the name <code>x</code> to the value <code>3</code>.</p></li>
</ol>
<pre><code>var x = 2                      | 0      |        |
                               |        |        |
func f(y: Int) -&gt; Int {        | 1      |        |
    return x + 2               |        |        |
}                              |        |        |
                               |        |        |
func g(x: Int) -&gt; Int {        | 2      |        |
    if x == 3 {                |        |        | 0 &lt;---
        let z = 3              |        |        |
        return z + 4           |        |        |
    }                          |        |        |
    return x + 10              |        |        | 1
}                              |        |        |
                               |        |        |
func h() {                     | 3      |        |
    print(f(y: x) + g(x: 3))   |        | 0 &lt;--- |
}                              |        |        |
                               |        |        |
let z = h()                    | 4 &lt;--- |        |</code></pre>
<p><img src="../Other/Environment-Images/example-4.png" style="zoom:30%;" /></p>
<ol start="9" type="1">
<li>Statement 0 in g is an <code>if</code> statement. First we have to evaluate the condition. We do not create a new frame for the built-in operator (==). We evaluate its first argument <code>x</code> by lookup in the current frame. This is an example <em>variable shadowing</em> in which a binding in the current frame hide bindings with the same name in its ancestor frames. We then evalute the second argument <code>3</code> to the value <code>3</code>, which means the entire condition evalutes to <code>true</code>. So we have to create another frame.</li>
</ol>
<pre><code>var x = 2                      | 0      |        |        |
                               |        |        |        |
func f(y: Int) -&gt; Int {        | 1      |        |        |
    return x + 2               |        |        |        |
}                              |        |        |        |
                               |        |        |        |
func g(x: Int) -&gt; Int {        | 2      |        |        |
    if x == 3 {                |        |        | 0 &lt;--- |
        let z = 3              |        |        |        | 0 &lt;---
        return z + 4           |        |        |        | 1
    }                          |        |        |        |
    return x + 10              |        |        | 1      |
}                              |        |        |        |
                               |        |        |        |
func h() {                     | 3      |        |        |
    print(f(y: x) + g(x: 3))   |        | 0 &lt;--- |        |
}                              |        |        |        |
                               |        |        |        |
let z = h()                    | 4 &lt;--- |        |        |</code></pre>
<p><img src="../Other/Environment-Images/example-5.png" style="zoom:30%;" /></p>
<ol start="10" type="1">
<li>Statement 0 in the <code>if</code> statement is a simple constant declaration which creates a binding in the current frame. The next and last statement in the frame is a return statement. Evaluating its expression yields the value <code>7</code>. We then label the frame DONE. Since it is not a frame for a function call, we do not include the RETURN binding. Its parent frame <em>is</em> the frame for the function call of <code>g</code>, so we include the RETURN binding here and label the frame DONE, ignoring all later statements.</li>
<li>We have finished evaluating the argument to <code>+</code> in Statement 0 for <code>h</code>. The print statement does not have any output, so this expression evaluates to <code>()</code>. Since there are no more lines to execute, we include the RETURN binding to <code>()</code> and label the frame DONE.</li>
<li>Finally, we have finished evaluating the object of the declaration in Statement 5 in the global frame. The name <code>z</code> is the bound to the value <code>()</code> in the global frame. Since this is the last line in the global frame, we label the frame DONE.</li>
</ol>
<p><img src="../Other/Environment-Images/example-done.png" style="zoom:28%;" /></p>
<p>In practice, if you have to draw an environment diagram you don't need this much detail. You can skip simple steps in the evaluation process, as long as you create all the necessary frames.</p>
<h2 id="captured-variables-and-escaping-functions">Captured Variables and Escaping Functions</h2>
<p>With environment diagrams, we can now see the mechanics of captured variables and escaping functions as an effect of the semantics. The important fact to note is that the lookup procedure still looks at frames labeled by DONE when trying to find the value of a name. Consider the following program</p>
<pre><code>func makeIncrementer() -&gt; () -&gt; Int {
    var y = 0
    func inc() -&gt; Int {
        y += 1
        return y
    }
    return inc
}

var f = makeIncrementer()
f()
f = makeIncrementer()
f()</code></pre>
<p>The first statement creates a simple function binding. For the second binding, we first have to create a new frame for the call to <code>makeIncrementer()</code>. In the new frame, we have two bindings and a return value. Once this frame has finished executing, <code>f</code> points to the same function object as <code>inc</code>.</p>
<p><img src="../Other/Environment-Images/capture-1.png" style="zoom:33%;" /></p>
<p>Calling <code>f</code> in the next statement creates a new frame (note it is still named <code>inc</code>, the actual defined function name), but the parent of this frame is not the global frame because the function object for <code>f</code> was not defined there, but in the frame for <code>makeIncrementer</code>. Now when we execute the statements in <code>inc</code>, the lookup for <code>y</code> will check the frame for <code>makeIncrementer</code> and update the value of <code>y</code> there.</p>
<p><img src="../Other/Environment-Images/capture-2.png" style="zoom:40%;" /></p>
<p>For reassignment of <code>f</code> and the second call to <code>makeIncrementer</code>, we make <em>another</em> frame for <code>makeIncrementer</code>, and another function object for <code>inc</code>. So the second call to <code>f</code> will update the <em>new</em> instance of <code>y</code> in this second <code>makeIncrementer</code> frame, ending in this final diagram.</p>
<p><img src="../Other/Environment-Images/capture-done.png" style="zoom:36%;" /></p>
</body>

</html>
