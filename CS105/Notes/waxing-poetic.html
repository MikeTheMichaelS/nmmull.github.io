<!DOCTYPE html>
<html>

<head>
<title>Waxing Poetic</title>
<link rel="stylesheet" href="../../globalStyle.css">
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body id="course">
<h1>Waxing Poetic</h1>
<p>An introductory programming course customarily begins with the instructor waxing poetic about the awesome power and scope of computing. They might use provocative terms like <em>artificial intelligence</em> and <em>big data</em>, of course, without explaining what they really are. Even in the relatively short time that I have been studying computer science, such introductions have lost some of their impact. Nowadays, everyone witnesses daily the effects of computing on their own lives. The dramas of the tech industry are a regular part of social and political discussions, to the extent that new terminology has been introduced into the general lexicon. Learning to program now is more than learning to write code. It's also learning to understand the context and implications of programs. It's recognizing when programming causes harm under false pretenses, or when its complexity is used as deniability to such harm. I cannot completely eliminate my own need to wax poetic about programming, but I think a new kind of introduction is in order.</p>
<p>It is difficult to exactly define programming as an activity. I will do my best to express my views throughout these notes, but despite my best efforts and my generally knowing better, I cannot help but generate a bunch of aphorisms of the from <em>programming is BLANK</em>. I apologize in advance; in any other setting, I might find this incredibly annoying.</p>
<p><em>Programming is challenging.</em> Programming requires immense technical skill, constant practice, and a bit of obsession. When programming, one has to simultaneously manage a not-so-small collection of considerations: efficiency, usability, reusability, scalability, safety, security, among others. We will cover a number of these, but many will come only from experience and exposure. Big companies (Apple, Google, Microsoft, etc.) often push the narrative that programming is "easy" and infinitely rewarding. They create games that claim to teach programming and week-long bootcamps that promise increased job prospects. But their interests are not in pedagogy; they are looking to increase their pool of applicants and grow their application marketplaces. I am not trying to discourage anyone; in actuality, I am trying to do the opposite. Calling programming <em>easy</em> devalues the time and frustration you will inevitably put into it.</p>
<p><em>Programming is ethically complex and dangerous.</em> If you code professionally, you will likely experience tension between your career and your personal ethics. This is just the reality, and it would be irresponsible not to address it. Programmers often work with sensitive data, not all of which is ethically obtained. Some programs make decisions about life and death of other human beings, like in automated transportation and medical software, and pressure from higher-ups lead to their premature release. Programs have been known to be racist, to promote gentrification, to enforce prejudice. <em>Of course programs can be anything</em>, someone might argue, and of course only those with malice intentions design malicious software. What's terrifying is that many of the programs that do cause harm are not specifically designed to do so. Programmers with good intentions can create software with entirely disastrous consequences. And this disparity is used to justify the consequences, and even to obfuscate deliberate harm. So it is not enough to have good intentions. Programming as not an isolated endeavor, it is not <em>just engineering</em>, independent of its use and context. Recognizing this means having a robust, nuanced, and thoughtful set of personal morals regarding programming; it is the duty of the programmer to fight against all bad software, not just their own, and the consequences of bad software, even those unintentional, fall to the programmer.</p>
<p><em>Programming is an art.</em> I mean this literally, not as an empty analogy. Computer science as a whole has little to do with science. Programmers, in particular, do not apply the scientific method. There are no rules for how to program, and there are few restrictions on what can be accomplished. Programs are judged aesthetically on their composition and effects. Programmers have personal styles, and strong opinions about the style of others. These are attributes of an art. The upshot: there is no correct way to program, only principles that have proved useful and successful. We must be dubious of both the rule-followers and renegades. In this course, we will learn how to use some of these principles, but, more importantly we will try to understand <em>why</em> we use them. It will then be up to you to determine if they fit into your personal aesthetic, which you will develop throughout your entire lifetime as a programmer.</p>
<p>This last one is a personal favorite: <em>Programming is maintenance</em>. There is a distinct lack of appreciation for maintenance in American culture. To see this, just look at the dismal salaries of maintenance workers (and teachers, who, in my opinion, perform a sort of maintenance). In software design, there is a heavy emphasis rapid development, getting things working fast. It is, of course, good when software works, but great software is manageable, readable, up to date, well-documented, clear, correct. Many professional programmers spend far more time reading documentation, reading code, testing code, and planning code than they do producing code. I have a personal theory about all this: one reason why programmers get paid so well is that so many programmers produce so much unmaintained code that they inflate the difficultly of their tasks by an order of magnitude. Whether or not this is true, all programmers know deep down that maintenance, organization, clarity, are what make the long-term successful of a project.</p>
<p>This course is strange by its own nature. It is not a prerequisite for the major in computer science in the university, so it does have the same requirements on coverage. All this is made worse by the fact that this is my first time teaching a course online. Taken together, this is something of an experiment. I hope to cover everything that is typically covered in an introductory programming course, but my goal for this course has always been to fostering a mode of thinking, not to teach you how to write Swift code. This is especially true now that most of this course will be asynchronous learning. Regardless, please make sure to give me feedback if something is not working for you. We all need to collaborate on making this a valuable experience.</p>
<h2 id="additional-reading">Additional Reading</h2>
<ul>
<li>I stole many ideas for this chapter from [<a href="https://aeon.co/ideas/coding-is-not-fun-it-s-technically-and-ethically-complex">this article</a>].</li>
<li>This [<a href="https://arxiv.org/pdf/1908.09635.pdf">recent survey</a>] details some of the types of discrimination that happens due to bias in programs. The full article might be a bit out of reach at the moment, but the introduction is clear, and hopefully you can come back to it more confidently by the end of the course if you are interested.</li>
<li>It doesn't take much internet searching to find instances of software failures having dire consequences. [<a href="https://www.forbes.com/sites/taylorarmerding/2018/11/20/hard-questions-raised-when-a-software-glitch-takes-down-an-airliner/#142130987b1d">Here</a>] is an example of a more recent event.</li>
</ul>
</body>

</html>
