<!DOCTYPE html>
<html>

<head>
<title>Data Abstraction</title>
<link rel="stylesheet" href="../../globalStyle.css">
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body id="course">
<h1>Data Abstraction</h1>
<p>We are back to abstraction, this time for the design of structures to make our code more clear and scalable. We will get the same sort of benefits from data abstraction as we did from functional abstraction, but our motivations will be slightly different.</p>
<p>We described structures as a way to combine associated data and functions in a single package. This allows us great expressivity, but at the cost of conceptual complexity. If unchecked, this expressivity can make programs unwieldy, which is why we introduce the notion of data abstraction as a way to manage this complexity.</p>
<p>One benefit of functional abstraction that we mentioned but did not highlight was <em>modularity</em>. When we abstract out a procedure as a function, we can call that function anywhere in the program. And if we made an error in the procedure, we only have to fix it once, in the declaration of the function. More than that, if we come back to our code several days (or months depending on the time frame) later and realize that there is a better implementation, we can make a single local change that has effects throughout the entire program.</p>
<p>We had abstracted out the function for taking nonnegative powers of <code>Int</code>s in this way.</p>
<pre class="swift"><code>func powerInt(_ x: Int, toThe y: Int) -&gt; Int {
    assert(y &gt;= 0)
    var out = 1
    for _ in 0..&lt;y {
        out *= x
    }
    return out
}</code></pre>
<p>Now that we know recursion, we can write this is a more efficient way.</p>
<pre class="swift"><code>func powerInt(_ x: Int, toThe y: Int) -&gt; Int {
    if y == 0 { return 1 }
    let halfPower = powerInt(x, toThe: y / 2)
    return halfPower * halfPower * (y % 2 == 0 ? 1 : x)
}</code></pre>
<p>As a side note, let's think about why this implementation is more efficient. The first implementation requires <code>y</code> multiplications, one for each iteration of the <code>for</code> loop. It is a bit less clear how many the second implementation uses, but it performs two multiplications for each recursive call, of which there are roughly <span class="math inline">\(\log_2(y)\)</span>, or the number of times it takes to get <span class="math inline">\(1\)</span> by repeatedly halving <code>y</code>. Just to get a sense of the scale, this means that when the <code>y</code> is <span class="math inline">\(10^9\)</span> (one billion), the first implementation requires that many multiplications where as the second requires roughly <span class="math inline">\(60\)</span>.</p>
<p>Once we have changed the definition of the function, we don't have to change any code anywhere else, whereas if we had not abstracted out the procedure to a function, we would have might have to update the code in multiple places. By using the function as an abstraction, we create a <em>barrier</em> between the code that uses the function and the code within the function. Changes on one side of the barrier don't affect the other side of the barrier.</p>
<p>This will be our primary motivation for data abstraction. We are going to build <em>abstraction barriers</em> between the representation of data within a structure and the code that uses the structure, minimizing the amount of code that we have to change if the design of the structure changes, and even allowing us to delay the decision of how to represent the data in our structure.</p>
<p>Abstraction barriers are a key part of the design of computers in general. They are why, when we program in Swift, we don't have to think about how values are stored in memory, or how arithmetic operations are carried out by the circuits that make up your computer. Part of the motivation is economic. It would be unreasonably expensive for Apple to rewrite all its internal programs each time they made changes to hardware, or the update hardware every times they wanted to make large changes to those programs.</p>
<p>Programs can also be extremely complex, so we are going to find ourselves with similar design decisions. We don't want to have to rewrite our programs every time we change the representation of data in our structures. Imagine if we had to rewrite our Swift programs because Apple decided to change the way it implemented arrays. Fortunately, arrays are implemented using data abstraction, so changes to the internal representation of an array does not affect the functionality of arrays.</p>
<h3 id="type-aliasing">Type Aliasing</h3>
<p>I should mention at this point that we have already seen one kind of weak data abstraction in the form of type aliasing, with which we can give an alternative name to a type <code>Type</code> in a swift program.</p>
<pre class="swift"><code>typealias AlternativeName = Type</code></pre>
<p>This is a useful tool, but should be used sparingly. Type aliases should be used where there is a kind of value that has a simple type, like a <code>Double</code>, but has a particular interpretation in the context of the program.</p>
<p><em>Example.</em> If you are writing a music program which work with sine tones, the parameters which specify a sine tone will always be <code>Double</code>s, but we can use type aliasing to make clear in the intention of each <code>Double</code>.</p>
<pre class="swift"><code>typealias Frequecy = Double
typealias Wavelength = Double
typealias Volume = Double
func generateSineTone(frequency : Frequecy, wavelength : Wavelength, volume : Volume) {
    //code
}</code></pre>
<h2 id="running-example-for-data-abstraction-2d-rendering">Running Example for Data Abstraction: 2D Rendering</h2>
<p>Imagine we are designing a program for 2D rendering which draws a collection of objects in a 2D environment onto the screen. Before we can do any kind of drawing, we first have to represent the elements in the environment being drawn. We can use object-oriented design here and make each object a structure which contains all its own information.</p>
<p>The first kind of object that we would need is a point. This is not a dot or small circle that is rendered on the screen, but an invisible object with which other objects to express their positions.</p>
<pre class="swift"><code>struct Point {
    var x: Double
    var y: Double
}

let origin = Point(x: 0.0, y: 0.0)</code></pre>
<p>Simple enough, another kind of object we might want to draw is a line segment. Here is a potential starting point for such a structure.</p>
<pre class="swift"><code>struct LineSegment {
    var start : Point
    var end: Point
    var width: Double
}
</code></pre>
<p>There are plenty of methods that we might consider implementing for this structure, but lets focus one that shifts a line segment along the <span class="math inline">\(x\)</span>-axis.</p>
<pre class="swift"><code>struct LineSegment {
    var start : Point
    var end: Point
    var width: Double

    mutating func xShift(distance: Double) {
        start = Point(x: start.x + distance, y: start.y)
        end = Point(x: end.x + distance, y: end.y)
    }
}</code></pre>
<p>Now suppose we come back to this code and realize that it would have been better to represent our <code>Point</code> as a distance from the origin and the angle with the <span class="math inline">\(x\)</span>-axis in the counterclockwise direction. Maybe we are doing more rotations than translations, making this definition more natural.</p>
<pre class="swift"><code>struct Point {
    let distance: Double
    let angle: Double
}

let origin = Point(distance: 0.0, angle: 0.0)</code></pre>
<p>By changing this code, our definition of <code>.xShift(distance:)</code> no longer works, the <code>.x</code> and <code>.y</code> properties don't even exist anymore.</p>
<p>In writing the function <code>.xShift(distance:)</code> we <em>broke the abstraction barrier</em> for <code>Point</code>s.</p>
<blockquote>
<p>The <strong>abstraction barrier</strong> is an imaginary separation between the actual representation of the data contained in a structure and the functions that apply to those structures.</p>
</blockquote>
<p>We should be able to change code on one side of the barrier without it affecting the code on the other side. Of course, if we knew <em>nothing</em> about the representation of points then we couldn't actually do anything with them. We need some way to access information about <code>Points</code> in a way that does not assume the actual representation. We do this using <em>getter</em> and <em>setter</em> methods.</p>
<blockquote>
<p><strong>Getter and setter methods</strong> are methods in a structure for getting and setting values associated with a function, independent of the representation.</p>
</blockquote>
<p>We can imagine that these are doorways through which we are allowed to cross the abstraction barrier.</p>
<p>Starting over, we can can imagine writing <code>Points</code> and <code>LineSegments</code> using getter and setter methods as follows.</p>
<pre class="swift"><code>struct Point {
    var x: Double = 0.0
    var y: Double = 0.0

    init(x: Double, y: Double) {
        setX(to: x)
        setY(to: y)
    }

    func getX() -&gt; Double {
        return x
    }

    mutating func setX(to newValue: Double) {
        x = newValue
    }

    func getY() -&gt; Double {
        return y
    }

    mutating func setY(to newValue: Double) {
        y = newValue
    }
}

struct LineSegment {
    var start : Point
    var end: Point
    var width: Double

    mutating func xShift(distance: Double) {
        start = Point(x: start.getX() + distance, y: start.getY())
        end = Point(x: end.getX() + distance, y: end.getY())
    }
}</code></pre>
<p>This is a much wordier definition, but I think its worth it for the sake of abstraction. Now if we change the underlying representation of a <code>Point</code> we only have to change our getter and setting methods.</p>
<pre class="swift"><code>struct Point {
    var distance: Double = 0.0
    var angle: Double = 0.0

    init(x: Double, y: Double) {
        setX(to: x)
        setY(to: y)
    }

    func getX() -&gt; Double {
        return distance * cos(angle)
    }

    mutating func setX(to newValue: Double) {
        let newDistance = sqrt(newValue * newValue + getY() * getY())
        let newAngle = acos(newValue / newDistance)
        distance = newDistance
        angle = newAngle
    }

    func getY() -&gt; Double {
        return distance * sin(angle)
    }

    mutating func setY(to newValue: Double) {
        let newDistance = sqrt(getX() * getX() + newValue * newValue)
        let newAngle = asin (newValue / newDistance)
        distance = newDistance
        angle = newAngle
    }
}</code></pre>
<p>We're not quite done, if we also want to write function for rotations it will be easier to use the new representation of points, but we should not use the actual data representation, i.e. the actual variables <code>distance</code> and <code>angle</code>. These should also get their own getter and setter methods.</p>
<pre class="swift"><code>struct Point {
    var distance: Double = 0.0
    var angle: Double = 0.0

    init(x: Double, y: Double) {
        setX(to: x)
        setY(to: y)
    }

    func getDistanceFromOrigin() -&gt; Double {
        return distance
    }

    mutating func setDistanceFromOrigin(to newValue: Double) {
        distance = newValue
    }

    func getAngleInRadians() -&gt; Double {
        return angle
    }

    mutating func setAngle(radians: Double) {
        angle = radians
    }

    func getX() -&gt; Double {
        return distance * cos(angle)
    }

    mutating func setX(to newValue: Double) {
        let newDistance = sqrt(newValue * newValue + getY() * getY())
        let newAngle = acos(newValue / newDistance)
        distance = newDistance
        angle = newAngle
    }

    func getY() -&gt; Double {
        return distance * sin(angle)
    }

    mutating func setY(to newValue: Double) {
        let newDistance = sqrt(getX() * getX() + newValue * newValue)
        let newAngle = asin (newValue / newDistance)
        distance = newDistance
        angle = newAngle
    }
}

struct LineSegment {
    var start : Point
    var end: Point
    var width: Double

    mutating func xShift(distance: Double) {
        start = Point(x: start.getX() + distance, y: start.getY())
        end = Point(x: end.getX() + distance, y: end.getY())
    }

    mutating func rotateAboutOrigin(radians: Double) {
        start.setAngle(radians: start.getAngleInRadians() + radians)
        end.setAngle(radians: end.getAngleInRadians() + radians)
    }
}</code></pre>
<p>After all this, our <code>.xShift(distance:)</code> method never changes. And we can add a new <code>.rotateAboutOrigin(radians:)</code> method that is equally abstract. The import of all this might not immediately apparent from this small example, but you have to imagine we have written hundreds of functions that depend on the <code>Point</code> structure. Then the ability to make local updates when changing the internal representation of <code>Point</code> is hugely rewarding, at least when compared to changed each of those functions individually.</p>
<h2 id="computed-properties">Computed Properties</h2>
<p>I have presented data abstraction as I did above because it is general enough to apply to most languages in which this sort of thing is possible. But this is not actually how you would do abstraction in Swift. Being such a modern language, Swift has some very strong tools for abstraction, one of which is <em>computed properties.</em></p>
<p>One somewhat unsatisfactory feature of getter and setter methods is that they represent what should be properties. Our code would be more clear if we could restrict the use of methods to functions which perform more complicated procedures. We <em>could</em> store these values as properties and then update them every time we right a method, but this would really be no better than breaking the abstraction barrier. Using computed properties we can write getter and setter methods <em>for properties</em>.</p>
<p>The general syntax for a computed property is as follows.</p>
<pre class="swift"><code>var &lt;name&gt;: &lt;Type&gt; {
    get {
        &lt;statements&gt;
        return &lt;value&gt;
    }
    set(&lt;nameForNewValue&gt;) {
        &lt;statements&gt;
    }
}</code></pre>
<p>When the a computed property is accessed, the <code>get</code> function is called and when a computed property is assigned a new value, the <code>set</code> function is called. Let's see how this would look in the example above.</p>
<pre class="swift"><code>struct Point {
    var distanceFromOrigin: Double = 0.0
    var angleInRadians: Double = 0.0

    var x: Double {
        get {
            return distanceFromOrigin * cos(angleInRadians)
        }
        set(newValue) {
            let newDistance = sqrt(newValue * newValue + y * y)
            let newAngle = acos(newValue / newDistance)
            distanceFromOrigin = newDistance
            angleInRadians = newAngle
        }
    }

    var y: Double {
        get {
            return distanceFromOrigin * sin(angleInRadians)
        }
        set(newValue) {
            let newDistance = sqrt(x * x + newValue * newValue)
            let newAngle = asin (newValue / newDistance)
            distanceFromOrigin = newDistance
            angleInRadians = newAngle
        }
    }

    init(distanceFromOrigin: Double, angleInRadians: Double) {
        self.distanceFromOrigin = distanceFromOrigin
        self.angleInRadians = angleInRadians
    }

    init(x: Double, y: Double) {
        self.x = x
        self.y = y
    }
}

struct LineSegment {
    var start : Point
    var end: Point
    var width: Double

    mutating func xShift(distance: Double) {
        start = Point(x: start.x + distance, y: start.y)
        end = Point(x: end.x + distance, y: end.y)
    }

    mutating func rotateAboutOrigin(radians: Double) {
        start.angleInRadians += radians
        end.angleInRadians += radians
    }
}</code></pre>
<p>All we had to do was take our getter and setter function and put them into the <code>get</code> and <code>set</code> functions for the computed property. This greatly simplifies the code for the <code>LineSegment</code> methods, as we can use the computed properties just like any other properties. Also, the definition of <code>xShift(distance:)</code> here is the same as before. This means, when we changed the data representation in the <code>Point</code> struct, <em>we never had to do anything to the <code>xShift(distance:)</code></em>. This is one of the most important features of computed properties, they allows us to not think about abstraction until we have to.</p>
<p>You might have also noticed that, before we introduced computed properties, we technically broke the abstraction barrier for <code>LineSegment</code> by referring directly to <code>start</code> and <code>end</code> in the methods we wrote. With computed properties, this is not longer an issue. Suppose, for example, that we also want to change the representation a line segment to be a distance and an angle from a starting point. We can then define <code>end</code> as a computed property without changing any other parts of the code.</p>
<pre class="swift"><code>struct LineSegment {
    var start : Point
    var distanceFromStart: Double
    var angleInRadians: Double
    var width: Double
    var end: Point {
        get {
            var out = Point(distanceFromOrigin: distanceFromStart, angleInRadians: angleInRadians)
            out.x += start.x
            out.y += start.y
            return out
        }
        set(newEnd) {
            let xDiff = newEnd.x - start.x
            let yDiff = newEnd.y - start.y
            let newDistance = sqrt(xDiff * xDiff + yDiff * yDiff)
            let newAngle = acos(xDiff / newDistance)
            distanceFromStart = newDistance
            angleInRadians = newAngle
        }
    }

    mutating func xShift(distance: Double) {
        start = Point(x: start.x + distance, y: start.y)
        end = Point(x: end.x + distance, y: end.y)
    }

    mutating func rotateAboutOrigin(radians: Double) {
        start.angleInRadians += radians
        end.angleInRadians += radians
    }
}</code></pre>
<p>We now have two layers of abstractions when we refer to <code>.end.x</code>. Neither of these properties are stored, they are represented abstractly via computations. This allows us to write very natural code within our methods without dealing with the intricacies of switching between point and line segment representations.</p>
</body>

</html>
