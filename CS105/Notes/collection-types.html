<!DOCTYPE html>
<html>

<head>
<title>Collection Types</title>
<link rel="stylesheet" href="../../globalStyle.css">
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body id="course">
<h1>Collection Types</h1>
<p>I cannot imagine writing a much better introduction to collection types than what appears in the Swift book. Please read the chapter [<a href="https://docs.swift.org/swift-book/LanguageGuide/CollectionTypes.html#">Collection Types</a>]. You can ignore the sections on Sets and Set Operations if you want, we will revisit these. But first, we need to go over <em>Optionals</em>, another interesting idea co-opted from functional programming.</p>
<h2 id="optionals">Optionals</h2>
<p>We have a couple times now come across functions that are not naturally defined on all inputs. Take, for example, the <code>sum(upto:)</code> function, which, on input <span class="math inline">\(k\)</span>, returns the sum of the numbers from <span class="math inline">\(1\)</span> to <span class="math inline">\(k\)</span> <strong>if</strong> <span class="math inline">\(k\)</span> is positive and zero otherwise. In this otherwise-case, we made an arbitrary decision. But this could have bad consequences, if we accidentally call this function on a negative number, our program won't crash, but it will have undefined behavior. Generally speaking, undefined behavior is worse than crashing. At least when a program crashes the consequences are apparent. Undefined behavior mean unintended consequences.</p>
<p>One way to avoid this is to just force the program to crash on ill-formed inputs.</p>
<pre class="swift"><code>func sum(upto k: Int) -&gt; Int {
  assert(k &gt; 0)
  var accum = 0
  for i in 1...k {
      accum += i
  }
  return accum
}</code></pre>
<p>This works, but sometimes we don't want the program to crash. We want to handle potential issues within the code. Optionals allow us to do this. For every type <code>t</code>, there is an optional version of that type <code>t?</code>, equivalently written <code>Optional&lt;t&gt;</code>. We can think of <code>t?</code> as a box which <em>might</em> have a <code>t</code> inside it. If we use optionals as an output type of a function, we can return an empty box, formally an object <code>nil</code> of type <code>t?</code>, when the inputs to the function are ill-formed.</p>
<pre class="swift"><code>func sum(upto k: Int) -&gt; Int? {
  if k &lt;= 0 { return nil }
  var accum = 0
  for i in 1...k {
    accum += i
  }
  return accum
}

assert(sum(upto: 5) == 15)
assert(sum(upto: -20) == nil)</code></pre>
<p>Note that we didn't do anything to <code>accum</code> before returning it. And we compare <code>sum(upto: 5)</code> to <code>15</code> without doing anything special to make <code>15</code> an optional. This has to do with type-inference. The literals of <code>t?</code> are the same as those for <code>t</code>, so the type inference procedure can tell that <code>15</code> should be read as an <code>Int?</code>. Same with <code>accum</code>, the type inference procedure can tell it should be an <code>Int?</code> by looking at the output type of the function.</p>
<p>If something is a <code>t?</code>, then it is not of type <code>t</code> (clearly...), which means it can't, say, be used as an input to a function of type <code>(t) -&gt; o</code>, this is the point of types. So we need to be able to take the value of type <code>t</code> (if it exists) out of its box. This is called <em>unwrapping</em> (like a present!). We can <em>force unwrap</em> an optional value by following it with an exclamation mark.</p>
<pre class="swift"><code>var x: Int? = 2
var y: Int = x!</code></pre>
<p>If <code>x</code> was <code>nil</code>, this code would crash the program, so forced unwrapping should be done with caution, only when you <em>know</em> the there is a value in the box (otherwise, we might as well have just used an <code>assert</code> statement). We could, for example, first check if the box is empty with an <code>if</code> statement.</p>
<pre class="swift"><code>if x != nil {
    let y = x!
  //code for when x is not nil
}</code></pre>
<p>This pattern is so common with optionals that it has special syntax. The code</p>
<pre class="swift"><code>if let y = x {
    //code for when x is not nil
}</code></pre>
<p>is equivalent.</p>
<p>How are optionals related to collection types? Dictionaries are collections of key-value pairs, and so they have a function for accessing the value associated with a given key. But what happens if the key does not appear in the dictionary? The function returns <code>nil</code>.</p>
<h2 id="additional-reading">Additional Reading</h2>
<p>From the Swift book:</p>
<ul>
<li>[<a href="https://docs.swift.org/swift-book/LanguageGuide/TheBasics.html#ID330">Optionals</a>], this section has a bit more detail we won't need for this course, but you can check it out if you think you will want to program in Swift long-term</li>
</ul>
</body>

</html>
