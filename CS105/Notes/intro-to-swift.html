<!DOCTYPE html>
<html>

<head>
<title>Introduction to Swift</title>
<link rel="stylesheet" href="../../globalStyle.css">
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body id="course">
<h1>Introduction to Swift</h1>
<p>Swift was introduced in 2014 to replace Objective-C as the language for developing Apple applications. Despite the association with Apple, it's [<a href="https://github.com/apple/swift">open-source</a>] and can be used as a standalone language. We start by developing our knowledge of Swift enough to use it as a heavy-duty calculator (woohoo!).</p>
<p>Though I think writing URM programs is pretty satisfying, they're not going to work for solving actual problems. A couple issues (among the many):</p>
<ul>
<li>We could only write programs that work with natural numbers. This is sufficient for theoretical purposes; any other kind of data can be encoded using natural numbers. But a usable programming language should be <em>expressive</em>, it should be possible to write programs that are understandable. This is easier to do if we have different kinds of data that are interpreted in different ways.</li>
<li>When we computed a value for later use, we had to store it some register, remember that register, and then be careful not to accidentally write to that register in some other part of the program. This <em>modus operandi</em> won't scale well to more complicated programming tasks.</li>
<li>When we wanted to use one program as a subroutine, or combine multiple programs, we had to rewrite the code each time, changing the some instructions as necessary. This is irritating, especially since the first [<a href="http://threevirtues.com">great virtue of a programmer</a>] is laziness.</li>
</ul>
<p>We will see how many programming languages addresses these issues by looking at how Swift does.</p>
<h2 id="primitive-types-and-literals">Primitive Types and Literals</h2>
<p>Swift is a <em>strongly typed</em> language. This means all data that appears in a Swift program have attributed <em>types</em>. The type of a value is information about what kind of data it is, and how it should be interpreted. URM programs can be thought of as working with a single type <code>Nat</code> for natural numbers. Swift has many more types, along with mechanisms for creating new types. The <em>primitive types</em> are those that are built into Swift and are common among most full-scale languages. Because they are built-in and fundamental, there is special syntax for constructing fixed values of primitive types. Objects constructed this way are called <em>literals</em>.</p>
<h3 id="a-couple-primitive-types">A Couple Primitive Types</h3>
<ul>
<li><code>Int</code>. Values of type <code>Int</code> are whole numbers that can be negative, exactly as you saw them in grade school. <code>Int</code> literals are as expected, we can write numbers like <code>1</code>, <code>27</code>, <code>-2001</code> in Swift programs.</li>
<li><code>Double</code>. Values of type <code>Double</code> are decimal numbers. The name comes from the fact that they are "double" the precision of a different common data type for decimal numbers, the <code>Float</code> data type, which we will not use in this course. <code>Double</code> literals are also as expected: <code>1.23</code>, <code>2.001</code>, <code>-27.0</code>.</li>
<li><code>String</code>. Values of type <code>String</code> are representations of text. The way that Swift handles strings is admittedly a bit strange, so we will only be using them in a fairly basic capacity. The literals for <code>String</code> are sequences of characters surrounded by quotations: <code>"This is a string."</code>, <code>"1.23"</code>, <code>"&amp;())"</code>.</li>
<li><code>Bool</code>. I'm sure you can guess. There are only two values of type <code>Bool</code> given by the literals <code>true</code> and <code>false</code>.</li>
</ul>
<p>In addition to simple data types like these, we will also want to combine data types. The simplest way to do this is by using the <em>tuple</em> type. The tuple type depends on other types, it has the general form <code>(&lt;type1&gt;,..., &lt;typeK&gt;)</code>. Given values <code>v1,..., vK</code> of type <code>&lt;type1&gt;,..., &lt;typeK&gt;</code> (not necessarily distinct), the literal <code>(v1,..., vk)</code> is a value of type <code>(&lt;type1&gt;,..., &lt;typeK&gt;)</code>. So <code>(1, "one")</code> is a value of type <code>(Int, String)</code> and <code>(1, 1)</code> is a value of type <code>(Int, Int)</code>. Tuples should really only be used to combine at most three, maybe four, objects. We will eventually develop ways to create intricate compound data types which can be used for combining any number of objects.</p>
<p>There are two special cases of tuples. First: the singleton tuples, <code>(&lt;type&gt;)</code> is treated in roughly the same as <code>&lt;type&gt;</code>. The value <code>(((2)))</code> is technically distinct from <code>2</code>, but they are treated internally in exactly the same way, so you can ignore the surrounding parentheses. Second: the empty tuple <code>()</code> is also called <code>Void</code> and has a single value <code>()</code>. <code>Void</code> is used in swift to represent nothing (this is not the same as <code>nil</code>, which we will see later, that represents a different kind of nothing!).</p>
<h2 id="primitive-operators">Primitive Operators</h2>
<p>All of the above primitive types have a number primitive operators (functions) written for them. Binary operators are usually written with <em>infix</em> notation, where the operator name appears between its two arguments.</p>
<h3 id="some-useful-operators">Some useful operators</h3>
<ul>
<li><em>Addition</em> (<code>a + b</code>) can be applied can be applied to <code>Int</code>s, <code>Double</code>s and, interestingly, <code>String</code>s as concatenation (<code>"one" + "two"</code> = <code>"onetwo"</code>).</li>
<li><em>Subtraction</em> (<code>a - b</code>) applies to <code>Int</code>s and <code>Double</code>s as expected.</li>
<li><em>Multiplication</em> (<code>a * b</code>) applied to <code>Int</code>s and <code>Double</code>s as expected.</li>
<li><em>Division</em> (<code>a / b</code>) applies to <code>Int</code>s as floor division (<code>10/3</code> is <code>3</code>) and <code>Double</code>s as expected.</li>
<li><em>Equals</em> (<code>a == b</code>) applies to any two primitive types. It is <code>true</code> if they are the same, and <code>false</code> otherwise.</li>
<li><em>Not equals</em> (<code>a != b</code>) is the opposite of <code>==</code>.</li>
<li><em>Greater than</em> (<code>a  &gt; b</code>) applies to <code>Int</code>s and <code>Double</code>s as expected.</li>
<li><em>Less than</em> (<code>a &lt; b</code>) applies to <code>Int</code>s and <code>Double</code>s as expected.</li>
<li><em>Greater than or equal to</em> (<code>a  &gt;= b</code>) applies to <code>Int</code>s and <code>Double</code>s as expected.</li>
<li><em>Less than or equal to</em> (<code>a &lt;= b</code>) applies to <code>Int</code>s and <code>Double</code>s as expected.</li>
<li><em>Not</em> (<code>!a</code>) applies to a <code>Bool</code> and behaves like <span class="math inline">\(\neg\)</span>.</li>
<li><em>And</em> (<code>a &amp;&amp; b</code>) applies to <code>Bool</code>s and behaves like <span class="math inline">\(\land\)</span>.</li>
<li><em>Or</em> (<code>a || b</code>) applies to <code>Bool</code>s and behaves like <span class="math inline">\(\lor\)</span>.</li>
</ul>
<h2 id="variables-and-constants">Variables and Constants</h2>
<p>To address the issue of storing values, Swift has both <em>variables</em> and <em>constants</em>. The syntax is simple, to declare a constant we use the line</p>
<pre class="swift"><code>let &lt;name&gt;: &lt;type&gt; = &lt;value&gt;</code></pre>
<p>and to declare a variable we use the line</p>
<pre class="swift"><code>var &lt;name&gt;: &lt;type&gt; = &lt;value&gt;</code></pre>
<p>where <code>&lt;name&gt;</code> is a sequence of characters naming the value in the program and <code>&lt;value&gt;</code> is the value with type <code>&lt;type&gt;</code>&#xA0;that is stored. So</p>
<pre class="swift"><code>var variableWithLongName: Int = 2</code></pre>
<p>declares a variable named <code>variableWithLongName</code> with value <code>2</code> that can be used throughout the program after its declaration (<em>note:</em> this is not strictly true, they are only available within their own <em>scope</em>, but we delay this discussion for now). It is convention in Swift to use <em>camelCase</em> for long variable names and constant names (camel because the capital letters looking like humps, I guess) with the first letter lowercase.</p>
<p>The obvious question at this point: <strong>What is the difference between a variable and a constant?</strong> The names are not accidental, it has to do with <em>assignment</em>. The <em>assignment operator</em> (<code>a = b</code>), takes two values of the same type, and if the one on the left is a variable, then it assigns the value of that variable to the value on the right. If the left argument is <em>not</em> a variable, if it is a constant or something else, then Swift will complain and tell you that you are trying to assign a value to something that is not assignable. So</p>
<pre class="swift"><code>var x: Int = 2
x = 3</code></pre>
<p>is valid Swift code and</p>
<pre class="swift"><code>let x: Int = 2
x = 3</code></pre>
<p>is not.</p>
<p>When a variable is reassigned, it must be assigned a value with the same type. It is called <em>static typing</em> when variables are given fixed types like this, as opposed to <em>dynamic typing</em> in which a variable might store values of different types throughout the execution of a program. This makes programs a bit safer because we always know what kind of data we are working with, but it can make programs wordy with all the type annotations. Fortunately, Swift also has powerful <em>type inference</em>, so it can usually guess the type of a declared variable and the type can be dropped.</p>
<pre class="swift"><code>var x = 2</code></pre>
<p>is sufficient because Swift can tell that <code>2</code> is an <code>Int</code>.</p>
<p>The inclusion of both variables and constants does not make Swift more powerful as a language. We could get a way with just variables, as is the case with many other languages. What we get is greater expressibility, readability and safety; it becomes clear which values does not change throughout the execution of a program. And if we are, say, writing a program that uses geometry (think graphics and animation), we can define <span class="math inline">\(\pi\)</span> as a constant</p>
<pre class="swift"><code>let pi = 3.14159</code></pre>
<p>and we can use it without worry that it was accidentally reassigned (this is just an example, in reality we would use <code>Double.pi</code>, Swift's built in <span class="math inline">\(\pi\)</span> value).</p>
<p>One tricky but ultimately powerful fact about the assignment operator is that it determines the value of the right argument <em>before</em> assigning it to the variable on the left. This means that we can write</p>
<pre class="swift"><code>var x: Int = 2
x = x + 1</code></pre>
<p>to mean "assign the value of <code>x</code> one greater than its current value." The role of reassignment in programming is another one of those hotly debated topics in the community. Swift is an <em>imperative language</em>, which means that its programs use statements to change the state of the program. Reassignment is fundamental to imperative languages but complicates their semantics (as we will see). The idea of writing programs without reassignment might seem unreasonable and maybe a bit baffling, but so-called <em>functional languages</em>, designed to eliminate all reassignments, make up a large part of the programming language landscape (e.g., Scheme, Haskell, Elm, among others).</p>
<h2 id="functions">Functions</h2>
<p>To address the subroutine problem of URMs, Swift (and every other reasonable language) has a mechanism for declaring functions, which are named blocks of reusable code. The general structure for a basic function declaration is</p>
<pre class="swift"><code>func &lt;funcName&gt;(&lt;in1&gt;: &lt;in1Type&gt;, ..., &lt;inK&gt;: &lt;inKType&gt;) -&gt; &lt;outType&gt; {
    &lt;body&gt;
}</code></pre>
<p>where</p>
<ul>
<li><p><code>&lt;funcName&gt;</code> is the name of the function (also in camelCase),</p></li>
<li><p><code>&lt;in1&gt;</code>,...,<code>&lt;inK&gt;</code> are names of input parameters,</p></li>
<li><p><code>&lt;in1Type&gt;</code>,..., <code>&lt;inKType&gt;</code> are types of the inputs,</p></li>
<li><p><code>&lt;outType&gt;</code> is the type of the output of the function, and</p></li>
<li><p><code>&lt;body&gt;</code> is a block of code with any number of lines.</p></li>
</ul>
<p>There are a couple variations on this structure which you will see in the additional reading.</p>
<p>It is convention in Swift to indent the body of a function one level greater than its declaration. The named inputs should appear in the body of the function, where they are treated as constants. The body should also contain one or more lines with the <code>return</code> keyword, which specify the output of the function and terminate the execution of the code in the body of the function, should that line be reached.</p>
<p>Here is a simple function which outputs the surface of a rectangular prism with given <code>length</code>, <code>width</code> and <code>height</code>.</p>
<pre class="swift"><code>func surfaceAreaOfRectangularPrism(length: Double, width: Double, height: Double) -&gt; Double {
  let side1 = length * width
  let side2 = width * height
  let side3 = length * height
  return (2 * side1) + (2 * side2) + (2 * side3)
}</code></pre>
<p>We can use a function after it is declared by <em>calling</em> it:</p>
<pre class="swift"><code>let x = surfaceOfRectangularPrism(length: 5.0, width: 5.0, height: 5.0) </code></pre>
<p>Note that we had to include the names of the parameters. This can be tedious. Fortunately, Swift has an interesting mechanism for using more readable parameters in function calls. For every parameter in a function declaration we can actually supply <em>two</em> names. The <em>outer name</em>, also called an <em>argument label</em>, is the name that used when calling the function. The inner name, sometimes just called the <em>parameter name</em>, is used in the body of the function. Supplying only one is equivalent to supplying both with the same name. Supplying <code>_</code> as the argument label allows you to call the function without an argument label. It is in Swift style to try to write argument labels so that function calls almost read like sentences. The function</p>
<pre class="swift"><code>func power(_ x: Double, toThe y: Double) -&gt; Double {
    &lt;WE DONT KNOW HOW TO WRITE THIS YET!&gt;
}</code></pre>
<p>can be called by</p>
<pre class="swift"><code>var x = power(2.0, toThe: 4.0)</code></pre>
<p>which I think is pretty neat.</p>
<h2 id="additional-reading">Additional Reading</h2>
<p>These are the sections in the Swift book covering the material in these notes.</p>
<ul>
<li>[<a href="https://docs.swift.org/swift-book/LanguageGuide/TheBasics.html#ID329">Tuples</a>]</li>
<li>[<a href="https://docs.swift.org/swift-book/LanguageGuide/BasicOperators.html#ID63">Arithmetic Operators</a>]</li>
<li>[<a href="https://docs.swift.org/swift-book/LanguageGuide/BasicOperators.html#ID70">Comparison Operators</a>]</li>
<li>[<a href="https://docs.swift.org/swift-book/LanguageGuide/BasicOperators.html#ID76">Logical Operators</a>]</li>
<li>[<a href="https://docs.swift.org/swift-book/LanguageGuide/BasicOperators.html#ID62">Assignment Operator</a>]</li>
<li>[<a href="https://docs.swift.org/swift-book/LanguageGuide/TheBasics.html#ID310">Constants and Variables</a>], note the section on printing, which is not covered in these notes.</li>
<li>[<a href="https://docs.swift.org/swift-book/LanguageGuide/TheBasics.html#ID322">Type Safety and Type Inference</a>], it be more detail than necessary, but worth reading.</li>
<li>[<a href="https://docs.swift.org/swift-book/LanguageGuide/Functions.html#ID159">Defining and Calling Functions</a>]</li>
<li>[<a href="https://docs.swift.org/swift-book/LanguageGuide/Functions.html#ID160">Function Parameters and Return Values</a>], you can ignore the last two subsections, there is also a section on returning no values and returning multiple values not covered in these notes.</li>
<li>[<a href="https://docs.swift.org/swift-book/LanguageGuide/Functions.html#ID166">Function Argument Labels and Parameter Names</a>], you can ignore the last three subsections.</li>
</ul>
<p>There are a few basic topics not covered in these notes that I expect you to read on your own.</p>
<ul>
<li>[<a href="https://docs.swift.org/swift-book/LanguageGuide/TheBasics.html#ID315">Comments</a>]</li>
<li>[<a href="https://docs.swift.org/swift-book/LanguageGuide/TheBasics.html#ID335">Assertions and Preconditions</a>], just the part about the <code>assert</code> function</li>
<li>[<a href="https://docs.swift.org/swift-book/LanguageGuide/BasicOperators.html#ID69">Compound Assignment Operators</a>]</li>
<li>[<a href="https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html#ID292">String Interpolation</a>]</li>
</ul>
</body>

</html>
