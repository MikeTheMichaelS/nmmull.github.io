<!DOCTYPE html>
<html>

<head>
<title>Collection Types</title>
<link rel="stylesheet" href="../../globalStyle.css">
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body id="course">
<h1>Collection Types</h1>
<p>Out of <del>laziness</del> resourcefulness, I've decided to punt most of your reading about collection types onto the Swift book. I can't imagine writing a much better section, especially because people tend not to have problems understanding collections, the hard part is remembering all the properties and methods associated with them.</p>
<p>So please read the section on [<a href="https://docs.swift.org/swift-book/LanguageGuide/TheBasics.html#ID329">Tuples</a>] and the chapter on [<a href="https://docs.swift.org/swift-book/LanguageGuide/CollectionTypes.html#">Collection Types</a>] minus the sections on sets and set operations.</p>
<p>For the remainder of this note, I'll give an overview of what you'll be reading about, how it fits into the framework we've built up so far, and I'll cover a couple odd-and-ends that will be necessary, but don't fit in naturally with any other material.</p>
<h2 id="tuples">Tuples</h2>
<p>So far we've talked about functions and basic types, but as our programs become more complicated, we're going to want cleaner ways of organizing our data. The simplest way to do this is to use tuples. In their simplest form, we add the following rule to our notion of type:</p>
<ul>
<li>If <code>T_1</code>,..., <code>T_k</code> are types, then <code>(T_1,..., T_k)</code> is a (tuple) type.</li>
</ul>
<p>We add the following rule to our notion of expression:</p>
<ul>
<li>If <code>e_1</code>,..., <code>e_k</code> are expressions of types <code>T_1</code>,..., <code>T_k</code>, respectively, then <code>(e_1,..., e_k)</code> is an expression of type <code>(t_1,..., t_k).</code></li>
</ul>
<p>And finally we add the following rule to our evaluation procedure:</p>
<ul>
<li>The value of <code>(e_1,..., e_k)</code> is <code>(v_1,..., v_k)</code> where <code>v_i</code> is the value of <code>e_i</code>. These values are determined from left to right.</li>
</ul>
<p>We can again verify the evaluation order with print statements.</p>
<pre class="swift"><code>func makeDouble(_ x: Double) -&gt; Double {
    print(&quot;evaluating makeDouble(\(x))...&quot;)
    return x
}

print((makeDouble(1.0), makeDouble(2.0), makeDouble(3.0)))</code></pre>
<p>prints:</p>
<pre><code>evaluating makeDouble(1.0)...
evaluating makeDouble(2.0)...
evaluating makeDouble(3.0)...
(1.0, 2.0, 3.0)</code></pre>
<h2 id="arrays">Arrays</h2>
<p>An <em>array</em> is an ordered list of values of the same type. It is an example of a <em>structure</em>, a kind of construction in Swift that allows us to organize data and functions. We'll have a whole module on structures, but for now we just need to know:</p>
<ul>
<li>Structure have initializers. These are like functions, but they have the consequence of constructing a new instantiation of a value of the given type. Initializers are used by calling the type like a function, e.g., <code>Array&lt;Int&gt;()</code> constructs an empty array.</li>
<li>Structures have values called <em>properties</em> associated with them, and well as functions called <em>methods</em>. These are accessed using <em>dot notation</em>. So rather than writing something like <code>count(l)</code> to get the number of elements in <code>l</code>, we write <code>l.count</code>. In the same way, rather than writing something like <code>append(2, to: l)</code> to add <code>2</code> to the end of <code>l</code>, we write <code>l.append(2)</code>.</li>
</ul>
<p><code>Array&lt;T&gt;</code> is an example of a <em>generic type</em>, also called a <em>parametric polymorphic type</em>. It depends on other types. This is an extremely powerful idea. Without it, we would need to have a different array type for every other type, i.e., an <code>ArrayInt</code>, <code>ArrayString</code>, and <code>ArrayArrayInt</code>... This gets tiresome fast. More on polymorphism to come.</p>
<p>Fitting this into our definitions from the last module, we add to our notion of type:</p>
<ul>
<li>If <code>T</code> is a type, then <code>Array&lt;T&gt;</code> (and <code>[T]</code>) is a type.</li>
</ul>
<p>We add to our notion of expression:</p>
<ul>
<li>If <code>e_1</code>,..., <code>e_k</code> are expressions of type <code>T</code>, then <code>[e_1,..., e_K]</code> is an expression of type <code>[T]</code>. In particular, <code>[]</code> is an expression of type <code>[T]</code>.</li>
<li>An <code>Array</code> initializer applied to appropriate arguments is an expression of the appropriate type. For example, <code>Array(repeating: 0.0, count: 3)</code> is an expression of type <code>[Double]</code>.</li>
</ul>
<p>And we add to our evaluation strategy:</p>
<ul>
<li>The value of <code>[e_1,...,e_k]</code> is <code>[v1,...,vk]</code> where <code>v_i</code> is the value of <code>e_i</code>. The values are determined from left to right.</li>
<li>The value of <code>Array(...)</code>, the application of an initializer, is determined by the definition of the initializer itself.</li>
</ul>
<h2 id="dictionaries">Dictionaries</h2>
<p>A <em>dictionary</em> is an unordered collection of key-value pairs, where the keys are unique. We add to our notion of types:</p>
<ul>
<li>If <code>K</code> and <code>V</code> are types, then <code>Dictionary&lt;K, V&gt;</code> or <code>[K:V]</code>.</li>
</ul>
<p>To our notion of expressions:</p>
<ul>
<li>If <code>k_1</code>,...,<code>k_n</code> are expressions of type <code>K</code> and <code>b_1</code>,..., <code>b_n</code> are expressions of type <code>V</code>, then <code>[k_1:b_1,..., k_n:b_n]</code> is an expression of type <code>[K:V]</code></li>
<li>Any constructor gives an expression of type <code>[K:V]</code></li>
</ul>
<p>The evaluation procedure for dictionaries is somewhat complicated so I won't write it down explicitly. This is partly because we can't think of a dictionary value as a literal. Literals are allowed to have repeated keys, on account of them being syntactic, but we really have to think of a dictionary as an unordered table, one that doesn't have a unique analog as a literal. Moving forward, we will stop writing out these formalities because the structures will only get more complicated, but it's important to know that it's always possible to do in principle.</p>
<h2 id="optionals">Optionals</h2>
<p>The last type construction I will mention is optionals. These are particularly useful for dictionaries.</p>
<p>We will often come across functions that are not naturally defined on all inputs. Take, for example, a function which finds the maximum value in an array if <code>Int</code>s.</p>
<pre class="swift"><code>func maximum(_ l: [Int]) -&gt; Int {
    var currentMax = -1
    for elem in l {
        if elem &gt; currentMax {
            currentMax = elem
        }
    }
    return currentMax
}</code></pre>
<p>What should this function return if the input is empty? Currently the function would return <code>-1</code>, which doesn't seems good. This could have unintended consequences if that number ends up getting used elsewhere in the program.</p>
<p>One option would be to force the program to crash. We can add the line</p>
<pre class="swift"><code>assert (l != [])</code></pre>
<p>to the beginning of the function's body to ensure that the program stops if this function is ever called on the empty array. Generally speaking, crashing is better than undefined behavior. Sometimes it's preferable for a program to crash, because a program shouldn't behave counter to its intended use.</p>
<p>But sometimes this isn't an option. Maybe the arrays we're working with do sometimes become empty. Another option would be to constantly check if our lists are empty. This is also undesirable because it's possible that we might forget to do this, we as programmers are fallible.</p>
<p>So what's left is to use optionals. For every type <code>T</code>, there is an optional version of that type, denoted <code>T?</code>, or <code>Optional&lt;T&gt;</code>. We can think of <code>T?</code> as a box which <em>might</em> have a <code>T</code> inside it, but it also might be empty. If we use an optional as the output type, we can return an empty box, the literal <code>nil</code>,&#xA0;in the cases where the function is not defined on the given input.</p>
<pre class="swift"><code>func maximum(_ l: [Int]) -&gt; Int? {
    if l == [] { return nil }
    var currentMax = -1
    for elem in l {
        if elem &gt; currentMax {
            currentMax = elem
        }
    }
    return currentMax
}</code></pre>
<p>Note that we didn't do anything to <code>currentMax</code> before returning it. This has to do with type inference. The literals of <code>T?</code> are the same as those for <code>T</code> and the type inference procedure can tell that currentMax is an <code>Int?</code> when it is declared since it is returned and the output type of <code>maximum</code> is&#xA0;<code>Int?</code>.</p>
<p>If something is a <code>T?</code>,&#xA0;then it is not a <code>T</code>&#xA0;(clearly...), which means it can't, say, be used as an input to a function of type <code>(T) -&gt; O</code>&#xA0;(this is the point of types). So we need to be able to take a value of type <code>T</code>&#xA0;out of its box (if the box is not empty). This is called <em>unwrapping</em>&#xA0;(like a present). We can <em>force unwrap</em>&#xA0;an optional value by following it with an exclamation point.</p>
<pre class="swift"><code>var x: Int? = 2
var y: Int = x!</code></pre>
<p>If <code>x</code> was <code>nil</code>, this code would crash the program, so forced unwrapping should be done with caution, only when you <em>know</em> the there is a value in the box (otherwise, we might as well have just used an <code>assert</code> statement like above). We could, for example, first check if the box is empty with an <code>if</code> statement.</p>
<pre class="swift"><code>if x != nil {
    let y = x!
  //code for when x is not nil
}</code></pre>
<p>This pattern is so common with optionals that it has special syntax. The code</p>
<pre class="swift"><code>if let y = x {
    //code for when x is not nil
}</code></pre>
<p>is equivalent.</p>
<p>How are optionals related to collection types? Dictionaries have a method for accessing the value associated with a given key, but what happens if the key doesn't appear in the dictionary?</p>
<h2 id="additional-reading">Additional Reading</h2>
<p>From the Swift book:</p>
<ul>
<li>[<a href="https://docs.swift.org/swift-book/LanguageGuide/TheBasics.html#ID330">Optionals</a>], this section has a bit more detail we won't need for this course, but you can check it out, especially if you want a deeper dive into Swift.</li>
</ul>
</body>

</html>
