<!DOCTYPE html>
<html>

<head>
<title>Lab 1: Getting set up</title>
<link rel="stylesheet" href="../../globalStyle.css">
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body id="course">
<h1>Lab 1: Getting set up</h1>
<p>You will need a number of software tools for this course (and beyond). Our goal in this lab is to make sure that you have everything you need installed.</p>
<h2 id="text-editor">Text Editor</h2>
<p>TextEdit is not going to cut it. You are going to want something with good replacing capabilities, syntax highlighting, bracket matching, and auto-indenting. Some seasoned programmers have strong opinions about text editors, so it's worth spending a bit of time now looking at your options.</p>
<ul>
<li><em>Sublime</em>. Sublime is likely the most popular simple code editor. It easy to use, looks quite good, and has a reasonable collection of features. It is "free" in the sense that you can download an unregistered version and use it indefinitely, with the caveat that it will intermittently pester you to register it. If you like it and have the means, I would recommend "donating" by registering.</li>
<li><em>Atom.</em> Atom is a free text editor developed by the people behind GitHub. It is a bit resource heavy but it is easy to use and highly customizable. It also has one of the better ecosystems for custom features, which are easily installed and uninstalled. If you use Atom, you will want to install the <strong>language-swift-3</strong> package for syntax highlighting.</li>
<li><em>Emacs and Vim.</em> I would not recommend using Emacs or Vim as your first editor unless you have a certain kind of obsession with efficiency. I personally live by Vim, and, though they are similar, the divide between Emacs users and Vim users in the computer science community is a strong one. Both editors are typically used in the command line (discussed in the next section) but they also both have external applications. They are highly customizable and have hundreds of keybindings to make moving around and manipulating files very fast. Both Vim and Emacs are preinstalled on macOS machines.</li>
</ul>
<p>Other (not necessarily free) options not described here are Notepad++, BBEdit, CodeRunner, and Visual Studio.</p>
<p>The last option, which I mention only because I will be using it for our meetings, is that you can develop Swift programs directly in Xcode by choosing the "command line tool" option under the macOS tab when creating a new project. It's nice for meetings because it combines the command line and the coding environment in one screen, which is better for Zoom. It also has the benefit of fairly good Swift-specific auto-complete capabilities and the ability to run code directly. The only downside is that it is a bit heavy-weight for our purposes, and students don't always have access to macOS, so there needs to be a uniform option for everyone. For grading, we will be testing your code with the Swift Compiler via Terminal, so if you do this, you cannot submit Xcode project folders for assignment solutions.</p>
<h2 id="terminal">Terminal</h2>
<p>The <em>command line</em> or <em>shell</em> is a tool for interacting with the file system and the programs in your computer. You will use the command line to compile and run Swift code. On machines with macOS, there is a command line application preinstalled called <em>Terminal</em>. When you open Terminal, you will see a prompt to input text. From here you can type commands to create files, move around your file system, and just about everything else. The terminal keeps track of a <em>working directory</em>, on which certain commands will depend. You can imagine that you are sitting <em>inside</em> the working directory. Some command allow you to jump into and out of new directories. Others will change the state of the items in the working directory. When a terminal is initiated, it starts at the <em>home directory</em>. Usually this is just your user directory which contains your Desktop, Documents, etc. but if you are unsure, you can run the command <code>echo ~</code> (type it in and press the enter key) to see what your home directory is. If you do this you will see a path to a directory on your computer. Paths are representations of hierarchically organized data, going deeper from left to right, with <code>/</code> separating a parent directory from its child directory. So <code>/dir1/dir2/f.ext</code> refers to a file <code>f.ext</code> in the directory <code>dir2</code>, which is in the directory <code>dir1</code>, which is in the <em>root directory</em> <code>/</code>, the starting point of the files system. The <code>~</code> symbol from above stands for your home directory, <code>.</code> stands for the working directory, and <code>..</code> stands for the parent of the working directory.</p>
<h3 id="some-useful-commands">Some useful commands</h3>
<ul>
<li><p><code>pwd</code> prints the name of the working directory.</p></li>
<li><p><code>ls</code> lists the files and directories in the working directory.</p></li>
<li><p><code>cd &lt;pathToExistingDirectory&gt;</code> changes your working directory to the existing directory at the given path. Note, if the working directory <code>/dir1/dir2</code> then <code>cd ..</code> changes it to <code>/dir1</code>.</p></li>
<li><p><code>mkdir &lt;directoryName&gt;</code> creates a new directory named <code>&lt;directoryName&gt;</code> in the working directory. This is equivalent to pressing the "add folder" button in Finder.</p></li>
<li><p><code>touch &lt;fileName&gt;</code> creates a file named <code>&lt;fileName&gt;</code> if it doesn't already exist, and does nothing otherwise.</p></li>
<li><p><code>rm &lt;fileName&gt;</code> removes a file named <code>&lt;fileName&gt;</code> from your working directory, if it exists. If you need to remove a directory and everything in it, you can use <code>rm -r &lt;directoryName&gt;</code>. This is equivlent to <code>Command-delete</code> in Finder.</p></li>
<li><p><code>cp &lt;fileName&gt; &lt;pathToDestination&gt;</code> copies the file named <code>&lt;fileName&gt;</code> if it exists to the location <code>&lt;pathToDestination&gt;</code> if it exists. You can also write <code>cp &lt;fileName&gt; &lt;pathToDestination&gt;/&lt;newName&gt;</code> if you want to change the name after copying. If you need to copy a folder and all of its contents, you can add <code>-r</code> like with <code>rm</code>. This is roughly equivalent to <code>Command-c</code>, <code>Command-v</code> in Finder.</p></li>
<li><p><code>mv &lt;fileOrDirectoryName&gt; &lt;pathToDestination&gt;</code> moves the file or directory named <code>&lt;fileOrDirectoryName&gt;</code> to the location <code>&lt;pathToDestination&gt;</code> if it exists. This is equivalent to dragging-and-dropping in Finder.</p></li>
</ul>
<p>If your are running a Windows machine, you will need to install two things:</p>
<ul>
<li>[<a href="https://www.putty.org">PuTTY</a>] is a command line interface, which you can use to connect to the UChicago Computer Science Department shell host <code>linux.cs.uchicago.edu</code>.</li>
<li>[<a href="https://winscp.net/eng/index.php">WinSCP</a>] is a file transferring interface for getting files onto the linux server.</li>
</ul>
<p>See [<a href="https://howto.cs.uchicago.edu/remote_access">this page</a>] for details. You can use all the above commands in the shell in PuTTY and use WinSCP to transfer files you work on locally to use in that shell. Feel free to contact me if you have trouble getting this set up (this is also the point of the lab meeting time). You will then need to use [<a href="https://howto.cs.uchicago.edu/nix:swift">this command</a>] to make the Swift compiler available on the linux server once you connect with PuTTY.</p>
<h2 id="swift-compiler">Swift Compiler</h2>
<p>We previously described an interpreter for executing URM programs as a procedure that, roughly, reads a URM program line by line and executes each instruction. Swift, on the other hand, is a <em>compiled</em> language. From our purposes, the difference between these two things is unimportant. For those interested, there are a number of resources available online explaining the differences (e.g., the [<a href="https://en.wikipedia.org/wiki/Interpreter_(computing)#Compilers_versus_interpreters">Wikipedia article</a>] is not terrible, though maybe a bit heavy-handed). In a line, a compiler reads the entire program first and translates it into a form that is more understandable to your computer, maybe optimize a couple parts if possible, as opposed to reading each line as they come.</p>
<p>You will use the Swift compiler through the command line with the command <code>swift</code>. Giving this command without any else will open the [<a href="https://swift.org/getting-started/#using-the-repl">Swift REPL</a>] (Read-Eval-Print-Loop). The Swift REPL as basically a command line for Swift, so instead of using the commands above, you can write lines of Swift code. The REPL will read the line, evaluate it, print the result, and then prompt for another line. This is a good way to test out basic ideas, interact with Swift and get immediate feedback. Personally, I use Swift as a calculator over the Apple Calculator Application. You can just open terminal, open the swift REPL, and then types arithmetic expressions like <code>2 + 3</code> and it will print the answer for you.</p>
<p>Of course, what we will primarily be doing is writing Swift programs, which are given in separate files. Even though a Swift program is just a glorified text file, it should always have the extension <code>.swift</code>. We can run the swift compiler on a Swift program <code>program-name.swift</code> by including it as an argument: <code>swift program-name.swift</code>. Doing this will execute the program.</p>
<p>If you haven't already, you should update Xcode to the newest version that your operating can handle. This will also update the Swift compiler. We are currently on version <code>5.2.4</code>, but anything above 5 should do. Honestly, Swift 4 should probably be fine too, I don't know all the updates in 5 compared to 4, but if you are getting strange errors with Swift 4, or cannot run code from the notes, then you might have to update.</p>
<h2 id="a-possible-workflow">A Possible Workflow</h2>
<p>I would recommend creating a directory somewhere easily accessible on your computer called <code>CS105</code> or something similar. If you want to put it on your Desktop, for example, you could use the UI like normal, or you can use the commands:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1"></a><span class="op">&gt;</span> <span class="bu">cd</span> ~/Desktop</span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="op">&gt;</span> <span class="fu">mkdir</span> CS105</span></code></pre></div>
<p>(the <code>&gt;</code> is not a part of the command, just the prompt from the command line). Then for each lab, or assignment you can create a folder with the relevant files. You can use the <code>touch</code> command to create empty files you might need. For this lab, you need the files <code>hello-world.swift</code> and <code>minus-one.urm</code>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1"></a><span class="op">&gt;</span> <span class="bu">cd</span> CS105</span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="op">&gt;</span> <span class="fu">mkdir</span> lab1</span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="op">&gt;</span> <span class="bu">cd</span> lab1</span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="op">&gt;</span> <span class="fu">touch</span> hello-world.swift</span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="op">&gt;</span> <span class="fu">touch</span> minus-one.urm</span>
<span id="cb2-6"><a href="#cb2-6"></a><span class="op">&gt;</span> <span class="fu">ls</span></span>
<span id="cb2-7"><a href="#cb2-7"></a><span class="ex">hello-world.swift</span>           minus-one.urm</span></code></pre></div>
<p>The last command <code>ls</code> is just a sanity-check to verify that the files were created. Now you can open these files with your text editor of choice. A neat trick for macOS users, the command <code>open &lt;directoryOrFile&gt;</code> opens a directory or file with its default application, so <code>open .</code> opens Finder at the working directory. If you are working with Atom, then you can also use <code>atom .</code> in the command line to open the working directory in Atom.</p>
<h2 id="hello-world">Hello World</h2>
<p>The Hello World program is considered somewhat of a right of passage in computer science. In my opinion it is a bit of a legacy practice; I imagine it was a lot more interesting to get your computer to output some text on the screen when it was much harder to set up computing systems, and before texting was a thing. For our purposes it is a way for you to play around with your text editor and the Swift compiler. Open the file <code>hello-world.swift</code> that you created and insert the lines</p>
<pre class="swift"><code>// hello world program

print(&quot;Hello World.&quot;)    // or anything your want the computer to say...</code></pre>
<p>The first line is a <em>comment</em>, a way of include information in a program that is not code. I'm sure we will talk a bit about the use of comments later, everyone has an opinion. Mine is that you should avoid them at all costs within code, but I will use them for pedagogical purposes. See [<a href="https://en.wikipedia.org/wiki/The_Elements_of_Programming_Style">this</a>] for some more opinions about comments. For now I don't care too much, I think trying to enforce style so early in learning to program is more stunting than it is useful. The last line is a <em>print statement</em> which writes its input to the command line. The input to the function <code>print</code> is a string, a Swift representation of text. When you are done, check that this works.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1"></a><span class="op">&gt;</span> <span class="ex">swift</span> hello-world.swift</span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="ex">Hello</span> World.</span></code></pre></div>
<h2 id="minus-one">Minus One</h2>
<p>In Assignment 2, you have to write a few URM programs. I have actually written a simple URM interpreter in Swift [<a href="../Code/Course/urm.swift"><code>urm.swift</code></a>] that you can use to test your code. First you have to put a copy of this code in your <code>lab1</code> directory. Feel free to look through it, my hope is that you should be able to write something similar by the end of the course. For this lab, you will write one more as a way to get familiar with your editor and the command line. In the <code>minus-one.urm</code> file, you should write a program that, on inputs <span class="math inline">\(x\)</span>, outputs <span class="math inline">\(\max(x - 1, 0)\)</span>. Once your have completed this, you can run</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1"></a><span class="op">&gt;</span> <span class="ex">swift</span> urm.swift minus-one.urm 5</span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="ex">4</span></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="op">&gt;</span> <span class="ex">swift</span> urm.swift minus-one.urm 0</span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="ex">0</span></span></code></pre></div>
<p><code>minus-one.urm</code> and <code>5</code> are additional arguments to the Swift complier and are used as inputs to the URM interpreter. If you accidentally write an infinite loop in your URM program, you can stop the process by typing <code>Control-d</code> in Terminal.</p>
<h2 id="submission">Submission</h2>
<p>Submit your file <code>minus-one.urm</code> to Canvas by <strong>Monday, June 29 at 6PM</strong>.</p>
</body>

</html>
