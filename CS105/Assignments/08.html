<!DOCTYPE html>
<html>

<head>
<title>Assignment 8</title>
<link rel="stylesheet" href="../../globalStyle.css">
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body id="course">
<h1>Assignment 8</h1>
<p>This assignment is due <strong>Monday, July 13 by 6:00PM</strong>. Submit a file <code>assignment8.swift</code> for problems 1 and 2, and submit a file <code>assignment8.pdf</code> with problems 3 and 4.</p>
<h2 id="problem-1-towers-of-hanoi">Problem 1: Towers of Hanoi</h2>
<p>This problem is a classic, and a great demonstration of the power of recursion. Towers of Hanoi is a simple game consisting of disks of different sizes and three pegs arranged from left to right in a line. The initial state of the game is to have a fixed number of disks on the leftmost peg. All disk are different sizes and are arranged in decreasing size from bottom to top. The goal of the game is to move all disks from the left peg to the right peg (using the middle peg) so that the disks are arranged again in decreasing size from bottom to top. The trick is that you are only allowed to move one disk at a time and it must be a disk in the topmost position on a peg. See the game's [<a href="https://en.wikipedia.org/wiki/Tower_of_Hanoi">wikipedia page</a>] for more detailed rules but <strong>don't look at the solution given there!</strong></p>
<p>In this problem, you will use recursion to print a list of instructions for winning the game. Each instruction will be of the form</p>
<pre><code>Move disk from the {left, middle, right} peg to the {left, middle, right} peg.</code></pre>
<pre class="swift"><code>// this enumeration uses raw values from the additional reading
enum Peg : String {
    case left = &quot;left peg&quot;
    case middle = &quot;middle peg&quot;
    case right = &quot;right peg&quot;
}

func getOtherPeg(_ p : Peg, _ q : Peg) -&gt; Peg {
    var allPegs = [Peg.left, Peg.middle, Peg.right]
    allPegs.removeAll(where: { peg in peg == p} )
    allPegs.removeAll(where: { peg in peg == q} )
    return allPegs.first!
}

func printMove(from p : Peg, to q : Peg) {
    print(&quot;Move one disk from the \(p.rawValue) to the \(q.rawValue).&quot;)
}

// optional but useful helper function
// function for playing the game with different starting and finishing pegs
func hanoiHelper(numOfDisks n : Int, from s : Peg, to t: Peg) {
    //TODO: fill in code here (optional)
}

func towersOfHanoi(_ n: Int) {
    //TODO: fill in code here
}</code></pre>
<h2 id="problem-2-partitions">Problem 2: Partitions</h2>
<p>Complete the following function that returns the number of ways to write an positive integer <span class="math inline">\(n\)</span> as an unordered sum of positive integers. For example <span class="math inline">\(4\)</span> can be written as</p>
<ul>
<li><span class="math inline">\(4\)</span></li>
<li><span class="math inline">\(3 + 1\)</span></li>
<li><span class="math inline">\(2 + 2\)</span></li>
<li><span class="math inline">\(2 + 1 + 1\)</span></li>
<li><span class="math inline">\(1 + 1 + 1 + 1\)</span></li>
</ul>
<p>so the function should output <code>5</code>. In particular, <span class="math inline">\(1 + 3\)</span> is the same as <span class="math inline">\(3 + 1\)</span>, and should not be counted separately.</p>
<pre class="swift"><code>func partition(_ n: Int) -&gt; Int {
    if n &lt; 0 { return 0 }
    // TODO: fill in code here.
}</code></pre>
<h2 id="problem-3-call-order-and-memoization">Problem 3: Call Order and Memoization</h2>
<p>For this problem, you will first need to either reproduce or copy the recursive call tree for <code>fib(5)</code> from the notes. On this tree, label the nodes with numbers representing the order that the calls are made. The node labeled with <code>fib(5)</code> should be given the number <code>0</code>. Once you have done this, mark with the word LOOKUP the nodes whose values would be determined by lookup if memoization is used.</p>
<h2 id="problem-4-attempt-at-higher-order-memoization">Problem 4: Attempt at Higher-Order Memoization</h2>
<p>Your friend Zane is unsatisfied with our <code>fibMem</code> function because the method is not general enough. They show you an attempt at generalizing memoization using higher-order functions.</p>
<pre class="swift"><code>func memoize&lt;T&gt;(_ f: @escaping (Int) -&gt; T) -&gt; (Int) -&gt; T {
    var table = [Int: T]()
    func memoized(x: Int) -&gt; T {
        if let alreadyComputedValue = table[x] {
            return alreadyComputedValue
        }
        table[x] = f(x)
        return table[x]!
    }
    return memoized
}</code></pre>
<p>But they tell you that when they try it with <code>memoize(fibRec)(50)</code>, it doesn't actually make the function run any faster. Explain why this is the case.</p>
</body>

</html>
