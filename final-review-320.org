#+title: CAS CS 320 Review
#+subtitle: Principles of Programming Languages@@html:<br>@@
#+subtitle: Boston University@@html:<br>@@
#+subtitle: Spring 2023
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="globalStyle.css" />
#+HTML_LINK_HOME: index.html
#+OPTIONS: html-style:nil H:3 toc:2
This page contains an outline of the topics covered in /CAS CS 320:
Principles of Programming Languages/ during the Spring 2023 semester.
It is not exhaustive, and is biased towards those topics which are
most pertinent for the final exam of the course.  Included are
exercises associated with each topic.
* OCaml
During the first half of the course, we learned the function
programming language [[https://ocaml.org][OCaml]].  Our primary goal was to learn how to
program in the functional style, not thinking of a function as
defining a list of commands, but instead as specifying the /shape/ of
its output.
** Basics
OCaml has many types that are standard among programming languages,
e.g., integers, Boolean values, floating-point numbers, tuples and
lists, all with basic operators.  It also has standard functional
language constructs like let-bindings, anonymous functions, and
if-then-else expressions.
*** Exercises
1. Euclid's algorithm for determining the greatest common divisor of
 two integers takes advantage of the fact that $\mathsf{gcd}(m, n)
 = \mathsf{gcd}(n, m \bmod n)$.  Implement the function
 #+begin_src ocaml
   let gcd (m : int) (n : int) : int =
     assert false (* TODO *)
 #+end_src
 which, given two integers ~m~ and ~n~, returns their greatest
 common divisor.
2. We can represent a rational number as a pair of integers where the
   first integer represents the numerator and the second represents
   the denominator.  We maintain the invariant that the second number
   is positive and the pair of numbers are relatively prime.
   Implement the function ~add~ which adds two rational numbers,
   making sure to maintain this invariant.
   #+begin_src ocaml
     type rat = int * int

     let add (m : rat) (n : rat) : rat =
       assert false (* TODO *)
   #+end_src
3. Implement the function
   #+begin_src ocaml
     let gen_fib : (l : int list) (n : int) : int =
       if n < 0
       then assert false
       else
         assert false (* TODO *)
   #+end_src
   which, given a list of integers ~l~ of length $k$ and a nonnegative
   integer ~n~, returns the $n^\text{th}$ element of the following sequence:
   \begin{equation*}
   F_n =
   \begin{cases}
   l[n] & n < k \\
   \sum_{i = 1}^k F_{n - i} & n \geq k
   \end{cases}
   \end{equation*}
** Algebraic Data Types
One of the most important features of a modern functional programming
language is pattern matching and algebraic data types.  An algebraic
data type (ADT) is defined by giving a collection of *constructors*,
which may themselves carry other data.  We can think of algebraic data
types as defining *unions* of existing types.  Here, for example, is
an ADT whose values represent either a Boolean value or an integer.
#+begin_src ocaml
  type bool_or_int
    = Bool of bool
    | Int of int
#+end_src
We work with values of an ADT by *pattern matching*, providing
different output values depending on the /shape/ of the value we are
matching with.
#+begin_src ocaml
  let num_val (x : bool_or_int) : int =
    match x with
    | Bool b -> if b then 1 else 0
    | Int i -> i
#+end_src
ADTs can be *recursive* (the type being defined can be referred to in
its own definition) and *parametric* (the type being defined can
depend parametrically on another type).  These two features are
encompassed in the ~list~ type.
#+begin_src ocaml
  type 'a mylist
    = Nil
    | Cons of 'a * 'a mylist
#+end_src

~'a option~ and ~'a result~ also two other parametric types which are
important to be familiar with.

*** Exercises
1. Implement the function
 #+begin_src ocaml
   let matrix_of_list
     (l : 'a list)
     (num_cols : int) : ('a list list) option =
     assert false (* TODO *)
 #+end_src
 which converts a list ~l~ into a matrix with ~num_cols~ columns,
 returing ~None~ in the case that ~num_cols~ is not positive or the
 resulting matrix is not rectangular (i.e., the length of ~l~ is not
 a multiple of ~num_cols~).
2. Implement the function
   #+begin_src ocaml
     let drop_nones (l : 'a option list) : 'a list =
       assert false (* TODO *)
   #+end_src
   which returns an ~'a list~ consisting of those elements of ~l~
   which are not ~None~.
3. A Red-Black tree is an ordered binary tree in which every node is
   labeled either red or black.  It is further required that
   + no red node has a red child
   + every path from the root node to the leaf has the same number of
     black nodes
   Fill in the function ~is_valid~ below which returns ~true~ if ~t~
   is a valid red-black tree, and ~false~ otherwise.
   #+begin_src ocaml
     type color
       = Red
       | Black

     type 'a rbtree
       = Leaf
       | Node of (color * 'a * 'a rbtree * 'a rbtree)

     let is_valid (t : rbtree) : bool =
       assert false (* TODO *)
   #+end_src

   #+RESULTS:
   : type color = Red | Black
   : type 'a rbtree = Leaf | Node of (color * 'a * 'a rbtree * 'a rbtree)
** Record Types
*Record types* are essentially tuples with named fields.  Here is an
 example of a representation of rational numbers using record types.
#+begin_src ocaml
  type rat =
    { numer : int
    ; denom : int
    ; is_positive : bool
    }

  let two_thirds =
    { numer = 2
    ; denom = 3
    ; is_positive = true
    }
#+end_src
If we think of algebraic data types as unions, then we may think of
record types as *products* of existing types.  Beyond this, they have
a couple conveniences that are good to remember.
+ Accessing fields in a record can be done via dot notation, i.e., if
  ~r~ is a ~rat~ then ~r.is_positive~ is a ~bool~.
+ Updating a fields records can be done using ~with~-notation.  This
  is useful if a record has many fields but only a few need to be
  updated.
   #+begin_src ocaml
     let negate (r : rat) : rat =
       { r with is_positive = not r.is_positive }

     let recip (r : rat) : rat =
       if r.numer = 0
       then assert false
       else { r with numer = r.denom; denom = r.numer }
   #+end_src
*** Exercises
1. Fill in the record types below so that the given function type-checks.
   #+begin_src ocaml
     type rectangle1 = (* TODO *)

     type rectangle2 = (* TODO *)

     let transform (r : rectangle1) : rectangle2 =
       let (x, y) = r.center in
       { bottom_left = x -. r.width /. 2., y -. r.height /. 2.
       ; top_right = x +. r.width /. 2., y +. r.height /.  2.
       }
   #+end_src
2. Write a function which adds a binding the list of captured bindings
   of a closure, ensuring that it is shadowed by any bindings already
   in the collection of captured bindings.
   #+begin_src ocaml
     type closure =
       { name : string
       ; body : program
       ; captured : (string * value) list
       }

     let add_binding (c : closure) (x : string) (v : value) =
       assert false (* TODO *)
   #+end_src
3. Suppose you are given a list of tools for converting sound files
   from one format to another.  Each converter has a name, a list of
   input formats which it can convert from, and a list of output
   formats which it can convert to.  Implement the function
   ~convert_options~ which, given a list of converters ~cs~ and an
   input format ~f~, compiles the possible output formats, keeping
   track of the names of the converter tools which can be used.
   #+begin_src ocaml
     type converter =
       { name: string
       ; input_formats : string list
       ; output_formats : string list
       }

     type convert_out =
       { converters : string list
       ; output_format : string
       }

     let convert_options
       (cs : converter list)
       (f : string) : convert_out list =
       assert false (* TODO *)
   #+end_src
** Higher-Order Programming
*Higher-order programming* is the use of functions as *first-class
values* to write general, reusable code.  There are three patterns in
particular for higher-order programming with lists which we looked at
in depth.
+ The function ~map~, defined as
  #+begin_src ocaml
    let rec map (f : 'a -> 'b) (l : 'a list) : 'b list =
      match l with
      | [] -> []
      | x :: l -> let x = f x in x :: map f l
  #+end_src

  #+RESULTS:
  : <fun>
  replaces each element in ~l~ with ~f~ applied to that element, in
  order from left to right.
+ The function ~filter~, defined as
  #+begin_src ocaml
    let rec filter (p : 'a -> bool) (l : 'a list) : 'a list =
      match l with
      | [] -> []
      | x :: l -> if p x then x :: filter p l else filter p l
  #+end_src

  #+RESULTS:
  : <fun>
  find all element of ~l~ which satisfy the predicate ~p~, in order
  from left to right.
+ The function ~fold_right~, defined as
  #+begin_src ocaml
    let rec fold_right (f : 'a -> 'b -> 'b) (l : 'a list) (accu : 'b) : 'b =
      match l with
      | [] -> accu
      | x :: l -> f x (fold_right f l accu)
  #+end_src

  #+RESULTS:
  : <fun>
  applies the binary operation ~f~ between every element of ~l @ [accu]~ right-associatively:
  #+begin_src
     [x₁;   x₂;   x₃; ...   xₙ]
      ↓↓    ↓↓    ↓↓        ↓↓
    f x₁ (f x₂ (f x₃ (...(f xₙ accu)...)))
  #+end_src
  and the function ~fold_left~:
  #+begin_src ocaml
    let rec fold_left (f : 'b -> 'a -> 'b) (accu : 'b) (l : 'a list) : 'b =
      match l with
      | [] -> accu
      | x :: l -> fold_left f (f accu x) l
  #+end_src

  #+RESULTS:
  : <fun>
  does the same but to ~accu :: l~ left-associatively:
  #+begin_src
                       [x₁; x₂; x₃; ... xₙ]
                        ↓↓  ↓↓  ↓↓      ↓↓
    f (...(f (f (f accu x₁) x₂) x₃)...) xₙ
  #+end_src
  Note that ~fold_left~ is tail-recursive whereas ~fold_right~ is not.
*** Exercises
1. Implement the functions
   #+begin_src ocaml
     let andp (p1 : 'a -> bool) (p2 : 'a -> bool) : 'a -> bool =
       assert false (* TODO *)

     let orp (p1 : 'a -> bool) (p2 : 'a -> bool) : 'a -> bool =
       assert false (* TODO *)
   #+end_src
   with the following properties:
   + given two predicates ~p1~ and ~p2~, the predicate ~andp p1 p2~ is
     the predicate which expresses that both ~p1~ and ~p2~ hold.
   + given two predicates ~p1~ and ~p2~, the predicate ~orp p1 p2~ is
     the predicate which expresses that ~p1~ or ~p2~ hold.
2. We can represent a polynomial as a list of ~float~'s, where
   #+begin_src
           [a₀;  a₁;    a₂;     ...;  aₙ]
            ↓↓   ↓↓     ↓↓            ↓↓
     p(x) = a₀ + a₁ x + a₂ x² + ... + aₙ xⁿ
   #+end_src
   Implement the function
   #+begin_src ocaml
     let derivative (p : float list) : float list =
       assert false (* todo *)
   #+end_src
   which computes the list representing the polynomial $p'(x)$, the derivative of $p(x)$.
3. When implementing radix sort on integers, it is necessary to partition a list
   of integers based on their last digits.  Fill in the following function
   #+begin_src ocaml
     let bucket (l : int list) : int list list =
       let op accu next =
         assert false (* TODO *)
       in
       let base =
         List.init 10 (fun _ -> [])
       in
       List.fold_left op base l
   #+end_src
   which, given a list ~l~ of integers, return 10 lists of integers
   which partition ~l~ by the last digit the members of ~l~. That is,
   the $i^\text{th}$ element of ~bucket l~ should contain exactly the
   elements of ~l~ whose last digit is $i$.
** Tail Recursion
Roughly speaking, a recursive call in the body of a function
definition is in *tail position* if no evaluation is required /after/
the recursive call.[fn:: This can be made more formal by analyzing the
syntax of OCaml more carefully.]  The following implementation of the
factorial function is not tail recursive because it requires
evaluating the product of the result of its recursive call with the
input ~n~.
#+begin_src ocaml
  let rec factorial (n : int) : int =
    if n < 0
    then assert false
    else if n = 0
    then 1
    else n * factorial n
#+end_src
We can make functions tail recursive by adding an accumulator argument
to the function.[fn:: This is, of course, not the only way to achieve
this. We can also use continuation-passing style, as we saw briefly in
lecture.]
#+begin_src ocaml
  let factorial_tail (n : int) : int =
    let rec go (n : int) (accu : int) =
      if n = 0
      then accu
      else go (n - 1) (n * accu)
    in
    if n < 0
    then assert false
    else go n 1
#+end_src
*** Exercises
1. Consider the following function which prints a (half) hourglass out
   of asterisks.  Implement a function which does the same thing but
   is tail recursive.
   #+begin_src ocaml
     let rec hourglass (n : int) : unit =
       if n > 0
       then
         let _ = print_endline (String.make n '*') in
         let _ = hourglass (n - 1) in
         let _ = print_endline (String.make n '*') in
         ()
       else ()
   #+end_src
2. Implement a tail recursive evaluator for Boolean expressions as
   represented by the following ADT.
   #+begin_src ocaml
     type bool_expr
       = Bool of bool
       | Not of bool_expr
       | And of bool_expr * bool_expr
       | Or of bool_expr * bool_expr

     let eval_tr (e : bool_expr) : bool =
       assert false (* TODO *)
   #+end_src
** Type Checking
OCaml is *strongly typed*, and programs are statically checked for
adherence to typing rules.  We did not look at the type rules in full
detail, but we did see some examples of formal typing rules in OCaml,
e.g.,
\begin{equation*}
\frac
{b \in \mathsf{bool} \qquad e_1 \in \mathsf{t} \qquad e_2 \in \mathsf{t}}
{(\textsf{if } b \textsf{ then } e_1 \textsf{ else } e_2) \in \mathsf{t}}
\end{equation*}
This rule expresses that an if-then-else expression has the same type
as its if-case and else-case if its individual sub-expressions are
well-typed.[fn:: You are not required to write formal typing derivations,
but you should be able to use your intuitions about OCaml to determine
the type of an expression based on its structure (as the OCaml
type-checker does mechanically).]

OCaml also has *type inference*, which means we often do not have to
specify the types of expressions in OCaml programs (though it can be
useful for documentation purposes).
*** Exercises
1. Does this program type-check? If so, what are the types of ~bar~ and ~baz~?
   #+begin_src ocaml
     type 'a foo = Foo of ('a foo -> 'a)
     let bar (Foo f) = f
     let baz x = bar x x
   #+end_src
2. Does this program type-check? If so, what is the type of ~foo~?
   #+begin_src ocaml
     let rec foo x y =
       if x > 0 then
         foo (x - 1) (y +. 1.)
       else if x < 0 then
         foo y x
       else
         0
   #+end_src
* Formal Grammar
Grammar is the study of the form and structure of language.  We use
concepts from the formal grammar to represent and reason about the
syntax of programming languages.  These concepts also inform the
design of parsers.
** BNF Specifications
We start with a collection of symbols, separated into two disjoint
groups, the *nonterminal* symbols and the *terminal* symbols.  In a
Backus-Naur form (BNF) specification we use notation of the form
~<nonterm>~ to denote a nonterminal symbol.  We typically don't
specify the symbols in advance, but instead glean them from the
specification itself.

A *sentential form* is a sequences of symbols and a *sentence* is a
sequence of terminal symbols.

A *production rule* is made up of a nonterminal symbol and a
sentential form, and is written
#+begin_src
  <nonterm> ::= SENTFORM
#+end_src
We interpret a production rule as indicating that ~<nonterm>~ /stands
for/ ~SENTFORM~ in a sentential from.

A *BNF specification* is given by a collection of production rules and
a *starting symbol*.  We typically take the nonterminal symbol in the
/first/ rule of the specification to be the starting symbol.  We also
call a BNF specification a *grammar*.[fn:: It may be worth noting
that, in formal language theory, a grammar is a more general]

In the case that a BNF specification has multiples rules for the same
nonterminal symbol, we use the notation
#+begin_src
  <nonterm> ::= SENTFORM₁ | SENTFORM₂ | ... | SENTFORMₖ
#+end_src
as shorthand for
#+begin_src
  <nonterm> ::= SENTFORM₁
  <nonterm> ::= SENTFORM₂
   ...
  <nonterm> ::= SENTFORMₖ
#+end_src

A *derivation* of a sentential form $S$ in a grammar $\mathcal G$ with
start symbol ~<start>~ is a sequence of sentential forms, starting
with the start symbol ~<start>~ and ending in $S$, in which each form
in the sequence (except for ~<start>~) is the results of replacing /one/
nonterminal symbol in the previous form with a sentential from given
by a production rule of $\mathcal G$.

A derivation is *leftmost* if the nonterminal symbol replaced at each
step of the derivation is the leftmost nonterminal symbol in the
sentential form.

A grammar $\mathcal G$ *accepts* or *recognizes* a sentence
$S$ if has a derivation in $\mathcal G$.

A *parse tree*, informally, is a derivation represented as a tree, in which
+ every node is labeled with a symbol
+ the root is labeled with the starting symbol
+ the children of each node are the symbols of the sentential form (in
  order) which replace the symbol labeling the node in the derivation.

The *frontier* of a parse tree (i.e., the leaf nodes in order from
left to right) form the sentence derived in the derivation represented
by the parse tree.

A parse tree may correspond to multiple derivations, but every
derivation has a unique parse tree representation.  Likewise, every
parse tree corresponds to a unique /leftmost/ derivation.
*** Examples

/A toy grammar for English sentences:/
#+begin_src
  <sentence>    ::= <noun-phrase> <verb-phrase>
  <verb-phrase> ::= <verb> | <verb> <prep-phrase>
  <prep-phrase> ::= <prep> <noun-phrase>
  <noun-phrase> ::= <article> <noun>
  <article>     ::= the
  <noun>        ::= cow | moon
  <verb>        ::= jumped
  <prep>        ::= over
#+end_src
-----
/A (leftmost) derivation of a sentence recognized by the above
grammar:/[fn::The exclamation points are for emphasis, they are not a
part of the derivation.]

#+begin_src
  <sentence>!
  <noun-phrase>!     <verb-phrase>
  <noun-phrase>      <verb>  <prep-phrase>!
  <noun-phrase>!     <verb>  <prep>  <noun-phrase>
  <article>  <noun>  <verb>  <prep>  <noun-phrase>!
  <article>! <noun>  <verb>  <prep>  <article>  <noun>
  the        <noun>! <verb>  <prep>  <article>  <noun>
  the        cow     <verb>! <prep>  <article>  <noun>
  the        cow     jumped  <prep>! <article>  <noun>
  the        cow     jumped  over    <article>! <noun>
  the        cow     jumped  over    the        <noun>!
  the        cow     jumped  over    the        moon
#+end_src
-----
/A toy grammar for an imperative programming language:/
#+begin_src
  <program> ::= <stmts>
  <stmts>   ::= <stmt> | <stmt> ; <stmts>
  <stmt>    ::= <var> = <stmt>
  <var>     ::= a | b | c | d
  <expr>    ::= <term> | <term> + <term> | <term> - <term>
  <term>    ::= <var> | const
#+end_src
-----
/A (leftmost) derivation of a program recognized by the above grammar:/
#+begin_src
  <program>
  <stmts>
  <stmt> ; <stmts>
  <var> = <expr> ; <stmts>
  a = <expr> ; <stmts>
  a = <term> ; <stmts>
  a = const ; <stmts>
  a = const ; <stmt> ; <stmts>
  a = const ; <var> = <expr> ; <stmts>
  a = const ; a = <expr> ; <stmts>
  a = const ; a = <term> + <term> ; <stmts>
  a = const ; a = <var> + <term> ; <stmts>
  a = const ; a = a + <term> ; <stmts>
  a = const ; a = a + const ; <stmts>
  a = const ; a = a + const ; <var> = <expr>
  a = const ; a = a + const ; b = <expr>
  a = const ; a = a + const ; b = <term>
  a = const ; a = a + const ; b = <var>
  a = const ; a = a + const ; b = a
#+end_src
*** Extended BNF
We extend the notation of BNF specifications to make it more
convenient to use.[fn:: Other source may include more constructs in
EBNF syntax. See, for example, [[https://en.wikipedia.org/wiki/Extended_Backus–Naur_form][the Wikipedia page]].]
+ ~[ SENTFORM₁ | SENTFORM₂ | ... | SENTFORMₖ ]~ refers to an optional
  collection of alternatives of a sentential form.  For example, we
  can represent an integer by the following specification:
  #+begin_src
    <int>    ::= [ - ] <digits>
    <digits> ::= <digit> | <digit> <digits>
    <digit>  ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
  #+end_src
+ ~( SENTFORM₁ | SENTFORM₂ | ... | SENTFORMₖ )~ refers to a collection
  of alternatives /within/ a sentential form.  For example, we can
  represent arithmetic expressions by the following specification:
  #+begin_src
    <expr>   ::= <expr> ( + | - | * | / ) <expr> | <digits>
    <digits> ::= <digit> | <digit> <digits>
    <digit>  ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
  #+end_src
+ ~{ SENTFORM₁ | SENTFORM₂ | ... | SENTFORMₖ }~ to refer to zero or
  more occurrences of the sentential forms in a collection of
  alternatives. For example, we can simplify the specification for
  integers (and enforce that the first digit must be nonzero):
  #+begin_src
    <int> ::= [ - ] ( 1 | ... | 9) { 0 | ... | 9 }
  #+end_src
*** Exercises
1. List the symbols (both terminal and nonterminal) implicit in the following specification.
   #+begin_src
     <a> ::= a <b> | a <a> b
     <b> ::= c <a> | d
   #+end_src
2. Give a leftmost derivation of ~a a c a d b b~ in the above
   grammar. Draw its associated parse tree.
4. Verify that ~a = a + a ; b = b~ is recognized by the grammar for
   the simple imperative language above.  Give a derivation that is
   /not/ leftmost.
7. Implement the function
   #+begin_src ocaml
     type 'a tree
       = Leaf of 'a
       | Node of 'a tree list

     let frontier (t : 'a tree) : 'a list =
       assert false (* TODO *)
   #+end_src
   which returns a list of the members of ~t~ in order from left to
   right.
** Ambiguity
A BNF specification is *ambiguous* if there is a sentence with
multiple parse trees.  Equivalently, a specification is ambiguous if
there is a sentence with multiple leftmost derivations.  We try to
avoid ambiguous specifications for programming languages because we ultimately
don't want a program to be interpretable in multiple ways.
*** Fixity
The *fixity* of an operator refers to where the operator is written
with respect to its arguments.
+ *prefix* operators appear /before/ their argument
  + the negation operator: ~-5~
+ *postfix* operators appear /after/ their argument
  + type constructors: ~int list~
+ *infix* (binary) operators appear /between/ their arguments
  + arithmetic operators: ~(1 + 2) * (3 + 4)~)
+ *mixfix* operators are a combination of these
  + if-else-expressions: ~if not b the f x else g x~

If a language's syntactic constructs are all prefix (*Polish notation*)
or all postfix (*reverse Polish notation*) then the specification is
unambiguous.  We can make infix binary operators unambiguous by
specifying their associativity and precedence.
*** Associativity
An operator $\square$ is declared *left associative* if we interpret
$a \square b \square c$ as $(a \square b) \square c$.
+ For arithmetic expressions, we take subtraction to be
  left-associative, so the expression ~1 - 2 - 3~ evaluates to ~-4~
  as opposed to ~2~.

An operator $\square$ is declared *right associative* if we interpret
$a \square b \square c$ as  $a \square (b \square c)$.
+ For arithmetic expressions, we take exponentiation to be
  right-associative, so the expression ~2 ^ 1 ^ 3~ evaluates to ~2~
  as opposed to ~8~.

We can enforce the associativity of an operator in the specification itself.

TODO
*** Precedence
Given two binary operators $\square$ and $\triangle$, the operator
$\square$ has *higher precedence* than $\triangle$ if we interpret $a
\square b \triangle c$ as $(a \square b) \triangle c$ and $a \triangle
b \square c$ as $a \triangle (b \square c)$.
+ For arithmetic expressions, we take multiplication to have higher
  precedence than addition, so the expression ~2 * 2 + 3~ evaluates to
  ~7~ as opposed to ~10~.

As with associativity, we can enforce precedence within the
specification itself.

TODO
*** Exercises
1. Is this grammar ambiguous?
2. Find a sentence in this grammar which has multiple derivations.
3. Update this grammar so that it makes the operations precedence and hold
** Regular Grammars
A *(right linear) regular grammar* is a grammar whose rules are all of the following forms:
#+begin_src
  <nonterm> ::= term
  <nonterm> ::= term <nonterm>
  <nonterm> ::= ϵ
#+end_src
where $\epsilon$ refers to the empty sentence.

*Regular expressions* are a compact way of describing regular
grammars.  They are defined inductively as follows:
+ $\epsilon$ is a regular expression
+ if $r_1, r_2, \dots, r_k$ are regular expressions then so are
  $(r_1r_2 \dots, r_k)$ and $(r_1 \ | \ r_2 \ | \ \dots \ | \ r_k)$
+ if $r$ is a regular expression, then so is $r^*$

TODO acceptance

Regular grammars and regular expressions are equivalent in
expressivity.
*** Exercises
TODO
** Chomsky Normal Form
A grammar is in *Chomsky normal form* if its rule are all of the
following forms:
#+begin_src
  <start>   ::= ϵ
  <nonterm> ::= <nonterm> <nonterm>
  <nonterm> ::= term
#+end_src

Every grammar we have considered (i.e., every grammar with a BNF
specification) can be converted into an equivalent grammar (i.e., one
which accepts the same sentences) which is in Chomsky normal form.

*** Exercises
TODO
* Parsing
The general parsing problem is to find a derivation of a sentence in a
given grammar, if one exists. /(Aside. there is an efficient parsing
algorithm for grammars in Chomsky normal form)/

In the context of this course, we are primarily interested in the
specific problem of converting a ~string~ (or ~char list~) into an ADT
representing the syntax of the program.

There are many ways to accomplish this, we saw two:
*recursive-descent* and *parser-combinators*.

** Recursive-Descent

Recursive-descent parsing refers to an ad-hoc form of parsing in which
mutually recursive functions are defined to parse forms of a
specification.

This is best understood by example.

TODO

(Note: It is unlikely that recursive-descent parsing will appear on
the final exam in any significant way.)

** Combinators

We can think of a parser for ~'a~'s as a functions of type
#+begin_src ocaml
  type 'a parser = char list -> ('a * char list) option
#+end_src
which
1. consumes the prefix of the input stream corresponding to an ~'a~,
2. converts that prefix to an ~'a~, and finally,
3. returns that ~'a~ and the remainder of the stream, failing if no
   initial part of the stream corresponds to an ~'a~.

One of the simplest examples is the ~char~ parser:
#+begin_src ocaml
  let char (d : char) (cs : char list) : (char * char list) option =
    match cs with
    | c :: cs when c = d -> Some (d, cs)
    | _ -> None
#+end_src
which consumes the first character of ~cs~ given that it is equal to
~d~ and returns it, along with the remainder of ~cs~.  This parser
fails (returns ~None~) in the case that the first character of ~cs~ is
not ~d~.

When we want to /use/ a parser, we apply it to a character list and
verify that it consumed it's the entire input:
#+begin_src ocaml
  let parse (p : 'a parser) (s : string) =
    match p (explode s) with
    | (a, []) -> Some a
    | _ -> None
#+end_src

A *parser combinator* is a higher-order function which can be used to
compose parsers. There is a small subset of parser combinators which
are of particular importance because they correspond to the constructs
in EBNF specifications.
+ *Alternatives.* ~p1 <|> p2~ is the parser which tries running the
  parser ~p1~, returning its output if it succeeds, and running ~p2~
  otherwise.

  If ~p1~ is a parser for the forms of a nonterminal symbol ~<p1>~
  and ~p2~ a parser for forms of a nonterminal symbol ~<p2>~, then ~p1
  <|> p2~ is a parser for forms of the nonterminal symbol
  #+begin_src
    <alt> ::= <p1> | <p2>
  #+end_src
+ *Sequencing.* ~seq p1 p2~ is the parser which runs both ~p1~ and
  ~p2~ and returns both of their outputs if both parsers succeed.  It
  fails if either ~p1~ or ~p2~ fails.

  If ~p1~ is a parser for the forms of a nonterminal symbol ~<p1>~ and
  ~p2~ a parser for forms of a nonterminal symbol ~<p2>~, then ~p1 <|>
  p2~ is a parser for forms of the nonterminal symbol
  #+begin_src
    <seq> ::= <p1> <p2>
  #+end_src
+ *Repetition.* ~many p~ is the parser which runs ~p~ repeatedly until
  it fails, collecting all its outputs in a list.

  If ~p~ is a parser for the forms of a nonterminal symbol ~<p>~ and
  ~p2~ a parser for forms of a nonterminal symbol ~<p2>~, then ~many
  p~ is a parser for forms of the nonterminal symbol
  #+begin_src
    <many> ::= { <p> }
  #+end_src

The last important combinator is ~map~, which can be used to
manipulate the output of a parser without affecting how it consumes
its input.  If ~p~ is an ~'a parser~, and ~f~ is a function of type
~'a -> 'b~, then ~map f p~ is a ~'b parser~ which runs ~'a~ and then
applies ~f~ to its output (if it succeeds).

You should also be familiar with how to use the more convenient parser
combinators throughout the course (though, for the exam, you will not
be required to memorize their definitions).
+ ~str~, ~token~, ~ws~
+ (~>>~), (~<<~), ~seq3~, ~seq4~
+ (~>|~), ~map2~, ~map3~, ~map4~
+ ~pure~, ~fail~, (we will not test on ~bind~ (~>>=~) but it is good to know...)


*** Exercises
* Formal Semantics
In general, semantics is the study of the /meaning/ of language.  We
use concepts from the study of formal semantics to model the behavior
(i.e., the meaning) of programs.

We discussed two forms of semantics, *denotational* semantics and
*operational* semantics.

Giving a denotational semantics for a programming language means
assigning to each a /mathematical function/ which has the same
input/output behavior as the program.

In this course, we focus on operational semantics.  Giving an
operational semantics for a programming language means describing how
a program in the language is evaluated.  This typically means defining
a *reduction relation* on programs, which describes how a program is
reduced until it reaches a state which cannot be further reduced.

** Derivations
Suppose we have a programming language $\mathcal P$ defined by a given
BNF grammar.

A *configuration* is a pair consistent of a program $P$ and a state
$S$ which may be manipulated by programs.  The state may be empty, as
in the case of functional languages.

Defining the (small-step) operational semantics for $\mathcal P$ means
defining a reduction relation for configurations:

\begin{equation*}
( \ S \ , \ P \ ) \longrightarrow ( \ S' \ , \ P' \ )
\end{equation*}

A reduction relation is typically defined via *reduction rules*, which
consist of a /shape/ of a reduction together with a collection of
*premises*, which may be shapes of reductions or trivial premises
(also called axioms). The general form of a reduction rules is
something like

\begin{equation*}
\frac
{P_1 \qquad P_2 \qquad \dots \qquad P_k}
{C \longrightarrow C'}
\ \textsf{(name)}
\end{equation*}

/Shape/ here refers to the fact that the configurations in a reduction
rule contains /meta-variables/ that describe the /kind of reductions/
that can be derived, or that can be used a premises.  For example, the
rules for evaluating an arithmetic expression might include

\begin{equation*}
\frac{e_1 \longrightarrow e_1'}
{e_1 + e_2 \longrightarrow e_1' + e_2}
\ \textsf{(addLeft)}
\end{equation*}

which expresses that if $e_1$ reduces to $e_1'$ in a single step then
$e_1 + e_2$ reduces to $e_1 + e_2'$ in a single step /no matter the
expressions $e_1$, $e_1'$ and $e_2$/.  This rule can be used to show that

\begin{equation*}
(1 + 2) + 3 \longrightarrow 3 + 3
\end{equation*}

but also that

\begin{equation*}
(1 + (2 * 3)) + 3 \longrightarrow (1 + 6) + 3
\end{equation*}

Both reductions invoke that fact that if the left argument can be
reduced by a single step, then the sum can be reduced by a single
step.

A *derivation* is, informally, a tree in which each node is a
reduction and the children of a node are the premises required to
derive that conclusion.  The leaves of a derivation are trivial
premises (axioms).

A derivation of a reduction $C \longrightarrow C'$ is a derivation
whose root is $C \longrightarrow C'$.

TODO derivation

It is generally preferable that any derivable reduction has a unique
derivation.  This defining an evaluation procedure easier, and amounts
to fixing an *evaluation order*.  We can often enforce an evaluation
order via the structure of our reduction rules.

What we have been describing is a *single-step reduction relation*.
Any single-step reduction relation can be extended to a *multi-step
reduction relation* by including the following rules and a multi-step
reduction relation symbol '$\longrightarrow^{\star}$'.

\begin{equation*}
\frac
{}
{C \longrightarrow^\star C}
\ \textsf{(refl)}
\qquad
\frac
{C \longrightarrow^\star C' \qquad C' \longrightarrow C''}
{C \longrightarrow^\star C''}
\ \textsf{(trans)}
\end{equation*}

Formally, *evaluation* is the process of determining a configuration
$C'$ for a given configuration $C$ such that $C \longrightarrow^\star
C'$ and $C'$ cannot be further reduced (i.e., there is no other
configuration $C''$ such that $C' \longrightarrow C''$).

*** Exercises
1. Write a derivation for this reduction.
2. Find a configuration which this single-step reduces to.
3. Write a derivation for this multi-step reduction.
4. Find a configuration for this multi-step reduction.
5. Show that this reduction relation is not normalizing.
6. Show that this relation is not unique.
7. Make this reduction update the above relation so that it has unique
   reductions and arguments are evaluated from left to right.
** Examples
*** Arithmetic Expressions
*** The Lambda Calculus
*** A Stack-Oriented Language
One of the running examples we used for understanding operations
semantics was stack-oriented languages.

The following is a BNF specification for a stack-oriented language
whose programs manipulate a stack of integers.

-----
/Syntax of our base stack-oriented language:/
#+begin_src
  <prog>  ::= { <com> }
  <com>   ::= push <num> | dup | swap |
            | add | sub | mul
            | then <prog> else <prog> end
  <num>   ::= <digit> { <digit> }
  <digit> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
#+end_src
-----

Here, for example, is a program which puts the value of $14 + 15 + 16$
on top of the stack.
#+begin_src
  push 16 push 15 push 14
  add add
#+end_src
In the operational semantics of this language we take a configuration
to be a program ($P$) together with a stack of integers ($S$).

\begin{equation*}
( \ S \ , \ P \ )
\end{equation*}

together with a special irreducible $\mathsf{ERROR}$ configuration.
The operational semantics then describe how each command affects the
stack and the trace.

-----
/Operational semantics of our base stack-oriented language:/

\begin{equation*}
\frac{}{(\ S \ , \ \textsf{push n} \ P \ ) \longrightarrow ( \ n :: S \ ,\ P \ )}
\qquad
\frac{}{( \ m :: n :: S \ , \ \textsf{add} \ P \ ) \longrightarrow ( \ (m + n) :: S \ , \ P \ )}
\end{equation*}

\begin{equation*}
\frac{}{( \ n :: S \ , \ \mathsf{add} \ P \ ) \longrightarrow \mathsf{ERROR}}
\qquad
\frac{}{( \ \varnothing \ , \ \mathsf{add} \ P \ ) \longrightarrow \mathsf{ERROR}}
\end{equation*}

\begin{equation*}
\frac{}{( \ n :: S \ , \ \textsf{dup} \ P \ ) \longrightarrow
  ( \ n :: n :: S \ , \ P \ )}
\qquad
\frac{}{( \ \varnothing \ , \ \textsf{dup} \ P \ ) \longrightarrow \mathsf{ERROR}}
\end{equation*}

\begin{equation*}
\frac{}{( \ 0 :: S \ , \ \textsf{then} \ Q_1 \ \textsf{else} \ Q_2 \ \textsf{end} \ P \ ) \longrightarrow
( \ S \ , \ Q_2 \ P \ )}
\end{equation*}

\begin{equation*}
\frac{n \not = 0}{( \ n :: S \ , \ \textsf{then} \ Q_1 \ \textsf{else} \ Q_2 \ \textsf{end} \ P \ ) \longrightarrow
( \ S \ , \ Q_1 \ P \ )}
\end{equation*}

\begin{equation*}
\frac{}{( \ \varnothing \ , \ \textsf{then} \ Q_1 \ \textsf{else} \ Q_2 \ \textsf{end} \ P \ ) \longrightarrow
\mathsf{ERROR}}
\end{equation*}

-----

*** Exercises
Write a program which
* Variables
When introducing variables into a programming language, we also
introduce an *environment* into the configuration which maintains
variable bindings.

The structure of the environment depends on the scoping rules used in
the language, but in its simplest form, and environment is a mapping
of variable names to values.  This can be accomplished in OCaml with
an association list (i.e., a ~(string * value) list~.

An environment requires two operations: *fetch* and *update*.  The
fetch operation should get the value to which a variable is bound in
the environment.  The update operation should return a new environment
given a new binding.

In the case of a simple association list, we may write the following
OCaml implementation:
#+begin_src ocaml
  let fetch (e : (string * value) list) (x : string) : value option =
    List.assoc_opt x e

  let update
    (e : (string * value) list)
    (x : string)
    (v : value) : (string * value) list =
    (x, v) :: e
#+end_src
Different environment representations need different fetch and update
implementations, but regardless of how these functions are implemented,
they should satisfy the following equations.
#+begin_src ocaml
  let _ = assert (fetch [] x v = None)

  let _ = assert (
    if x <> y
    then fetch (update e x v) y = fetch e y
    else fetch (update e x v) y = v)
  )
#+end_src

-----
/Syntax of our base stack-oriented language:/
#+begin_src
  <prog>  ::= { <com> }
  <com>   ::= push <num> | dup | swap
            | add | sub | mul
            | then <prog> else <prog> end
            | fetch <var> | update <var>
  <num>   ::= <digit> { <digit> }
  <digit> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
#+end_src
-----

In the operational semantics of this language we take a configuration
to be a program ($P$) together with a stack of integers ($S$) and an
environment $E$ of variable bindings.

\begin{equation*}
( \ S \ , \ E \ , \ P \ )
\end{equation*}

together with a special irreducible $\mathsf{ERROR}$ configuration.

-----
/Operational semantics of a stack-oriented language with variables:/ They are
the same as above (with an additional `$E$' in the configurations)
plus the following rules.

\begin{equation*}
\frac{\mathsf{fetch}(E, x) \not = \bot}
{( \ S \ , \ E \ , \textsf{fetch} \ x \ P \ ) \longrightarrow
 ( \ \mathsf{fetch}(E, x) :: S \ , \ E \ , \ P \ )}
\qquad
\frac{\mathsf{fetch}(E, x) = \bot}
{( \ S \ , \ E \ , \textsf{fetch} \ x \ P \ ) \longrightarrow \mathsf{ERROR}}
\end{equation*}

\begin{equation*}
\frac
{}{( \ n :: S \ , \ E \ , \ \mathsf{update} \ x \ P \ ) \longrightarrow
( \ S \ , \ \mathsf{update}(E, x, n) \ , \ P \ )}
\end{equation*}

\begin{equation*}
\frac
{}{( \ \varnothing \ , \ E \ , \ \mathsf{update} \ x \ P \ ) \longrightarrow \mathsf{ERROR}}
\end{equation*}

-----

We need to specify how those
variable bindings are represented in a configuration.

When introducing variables to a programming language, we have to
specify when/where those bindings are accessible. This is called the
*scope* of the binding.  In general, this is a complex question, but
is broad strokes there are two paradigms: *dynamic scoping* and
*lexical scoping*.
* Subroutines
A *subroutine* is an encapsulated piece of code that can be reused and
run in different contexts.

It is not necessary to have variables in order to have subroutines.
Here is a simple stack-oriented language with subroutines.

-----
/Syntax of a stack-oriented language with subroutines:/

#+begin_src
  <prog>   ::= { <com> }
  <com>    ::= push <num> | add | then <prog> else <prog> end
             | def <ident> begin <prog> end | Call
  <num>    ::= <digit> { <digit> }
  <digit>  ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
  <ident>  ::= { <letter> }
  <letter> ::= A | B | C | ... | X | Y | Z

#+end_src
-----

-----
/Example program:/
#+begin_src
  def TRIPLE begin
    dup dup + +
  end
#+end_src
-----

-----
/Operational Semantics of a stack-oriented language with subroutines:/
** Parameter Passing
** Examples
*** Lambda Calculus with Call-by-Name Operational Semantics
*** Lambda Calculus with Call-by-Value Operational Semantics
*** Stack-Oriented Language with Subroutines
* Dynamic Scoping
*Dynamic scoping* refers to the use of /computational (temporal)
context/ to determine when a binding is available.  In its simplest
form, we may think of all bindings as globally available as soon as
they have been instantiated.

In a language with dynamic scoping and subroutines, when it comes to
determining what bindings are available, it doesn't matter where a
subroutine is defined, but rather where it is called.

Bash is a widely used language with dynamic scoping, but in general,
dynamic scoping is not common in modern programming languages.  It is,
however, much easier to implement than lexical scoping.

TODO EXAMPLE

** Stack-Oriented Language with Dynamic Scoping
TODO FILL IN

TODO EXAMPLE
* Lexical Scoping
*Lexical scoping* refers to the use of properties of the source code
 text to deliniate the availability of a binding.  In Python, the body
 of a function, determined by indentation, deliniates *function
 scope*.  In OCaml, The body of a let-expression is exactly the scope
 of its associated binding (it is not possible to refer to that
 binding outside of the body of the let-expression.  Lexical scoping
 is common among modern programming languages.

 In a language with lexical scoping and subroutines, when it comes to
 determining what bindings are available, it doesn't matter where a
 subroutine was called, but rather where it was defined.

 The way lexical scoping is implemented depends on a couple considerations:
 + Are variables *mutable*?
 + Are functions *higher-order*?

** Activation Records

Lexical scoping with /mutable/ variables requires maintaining a *call
stack*.  The call stack keeps track of the function calls made during
the evaluating a program, along with local variables to function calls.

Each function call creates an *activation record* (*frame*) which keeps track of:
+ the input parameters of the function
+ a pointer to the activation record in which the function was defined
+ a pointer to where to return after completing the function call.

We can think of an activation record as having the following rough structure.
#+begin_src
  +-------------+
  | local_n     |
  | local_n-1   |
  | ...         |
  | local_2     |
  | local_1     |
  | def_addr    |
  | return_addr |
  | arg_k       |
  | arg_k-1     |
  | ...         |
  | arg2        |
  | arg1        |
  | return_addr |
  +-------------+
#+end_src

Conceptually, we represent the call stack within the environment.
Rather than maintaining a collection of bindings, we maintain a stack
of activation records.

In OCaml, we might represent this as:
#+begin_src ocaml
  type record =
    { id : int
    ; locals : (string * value) list
    ; def_pointer : int
    ; ret_prog : program
    }

  type env = record list

  let fetch (e : env) (x : string) : value option =
    let rec go e x i =
      match e with
      | [] -> None
      | r :: e ->
        if r.id = i
        then
          match List.assoc_opt x r.locals with
          | Some v -> Some v
          | None -> go e x r.def_pointer
        else go e x (i - 1)
    in
    match e with
    | [] -> None
    | r :: _ -> go e x r.id

  let update (e : env) (x : string) (v : value) : env =
    match e with
    | [] -> assert false (* impossible *)
    | r :: e -> { r with locals = (x, v) :: r.locals }
#+end_src

Both of these function can be made more efficient.

*** Stack-Oriented Language with Mutable Variables and Lexical Scoping

Lexical scoping becomes more subtle to implement if functions are
higher-order.  In this example, we do not allow higher-order
functions, but we do allow nested function definitions.




** Closures
*Closures* are subroutines together with data they need to be executed
 correctly.  At a minimum, this data usually consists of a local
 environment, a collection of bindings, which may no longer be in
 scope when the function is called.  It may also include:
 + the name given to the subroutine
 + a pointer to the activation record in which the function was
   defined

Closures can be used to implement higher-order functions and lexically
scoped immutable variable bindings.  If variable bindings are
immutable, a subroutine can defined as a closure which stores all the
variable bindings it needs when it is defined.

Closure are also used in *continuation-passing style* implementations
of subroutines.  We can save a closure containing the current
environment and (a pointer to) the return program.

In OCaml:
#+begin_src ocaml
  type closure =
    { name: string
    ; body : program
    ; locals: (string * value) list
    }

  and value
    = Closure of closure
    | Num of int

  type env = closure option * (string * value) list
#+end_src

*** Stack-Oriented Language with Immutable Variables and Lexical Scoping

*** Exercises
*FIN*
