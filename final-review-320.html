<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2024-04-28 Sun 19:24 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CAS CS 320 Review</title>
<meta name="author" content="Nathan  Mull" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" href="globalStyle.css">
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="org-div-home-and-up">⟨ <a href="material.html">home</a> ⟩</div><div id="content" class="content">
<h1 class="title">CAS CS 320 Review
<br />
<span class="subtitle">Principles of Programming Languages<br> Boston University<br> Spring 2023</span>
</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orga9f916d">OCaml</a>
<ul>
<li><a href="#orgca217ba">Basics</a></li>
<li><a href="#orge0d51e5">Algebraic Data Types</a></li>
<li><a href="#orgcedadcd">Record Types</a></li>
<li><a href="#org87ba4af">Higher-Order Programming</a></li>
<li><a href="#orgf62c214">Tail Recursion</a></li>
<li><a href="#org5863bf9">Type Checking</a></li>
</ul>
</li>
<li><a href="#orge0e9d8a">Formal Grammar</a>
<ul>
<li><a href="#orgd39b698">BNF Specifications</a></li>
<li><a href="#org5fe2548">Ambiguity</a></li>
<li><a href="#org19c5b81">Regular Grammars</a></li>
<li><a href="#org5dd135d">Chomsky Norm Form</a></li>
</ul>
</li>
<li><a href="#org6a3f72d">Parsing</a>
<ul>
<li><a href="#org9664a00">Recursive-Descent</a></li>
<li><a href="#orgf8e306b">Combinators</a></li>
</ul>
</li>
<li><a href="#orga0ae140">Formal Semantics</a>
<ul>
<li><a href="#org86d466c">Derivations</a></li>
<li><a href="#orgc963db8">Examples</a></li>
</ul>
</li>
<li><a href="#orgd08fbca">Subroutines</a>
<ul>
<li><a href="#org599e14b">Parameter Passing</a></li>
<li><a href="#org186cdf4">Examples</a></li>
</ul>
</li>
<li><a href="#org2552d76">Environments</a>
<ul>
<li><a href="#org97147b3">Stack-Oriented Language with Variables</a></li>
</ul>
</li>
<li><a href="#orge83cf98">Dynamic Scoping</a>
<ul>
<li><a href="#org629ca0b">Stack-Oriented Language with Dynamic Scoping</a></li>
</ul>
</li>
<li><a href="#orgbc1fe25">Lexical Scoping</a>
<ul>
<li><a href="#orgf4a1425">Activation Records</a></li>
<li><a href="#org6e9edfe">Closures</a></li>
</ul>
</li>
<li><a href="#org6047722">Compilation</a></li>
<li><a href="#org54d3a2a">Solutions to Exercises</a></li>
</ul>
</div>
</div>
<p>
This page contains an outline of the topics covered in <i>CAS CS 320:
Principles of Programming Languages</i> during the Spring 2023 semester.
It is not exhaustive, and is biased towards those topics which are
most pertinent for the final exam of the course.  Included are
exercises associated with each topic.
</p>
<div id="outline-container-orga9f916d" class="outline-2">
<h2 id="orga9f916d">OCaml</h2>
<div class="outline-text-2" id="text-orga9f916d">
<p>
During the first half of the course, we learned the function
programming language <a href="https://ocaml.org">OCaml</a>.  Our primary goal was to learn how to
program in the functional style, not thinking of a function as
defining a list of commands, but instead as specifying the <i>shape</i> of
its output.
</p>
</div>
<div id="outline-container-orgca217ba" class="outline-3">
<h3 id="orgca217ba">Basics</h3>
<div class="outline-text-3" id="text-orgca217ba">
<p>
OCaml has many types that are standard in most programming languages,
e.g., integers, Boolean values, floating-point numbers, tuples and
lists, all with basic operators.  It also has standard functional
language constructs like let-definitions/bindings, anonymous
functions, and if-else expressions.
</p>
</div>
<div id="outline-container-org5f50e95" class="outline-4">
<h4 id="org5f50e95">Exercises</h4>
<div class="outline-text-4" id="text-org5f50e95">
<ol class="org-ol">
<li><p>
Implement the function
</p>
<div class="org-src-container">
<pre class="src src-ocaml">let matrix_of_list
  (l : 'a list)
  (num_cols : int) : ('a list list) option =
  assert false (* TODO *)
</pre>
</div>
<p>
which converts a list <code>l</code> into a matrix with <code>num_cols</code> columns,
returing <code>None</code> in the case that <code>num_cols</code> is not positive or the
resulting matrix is not rectangular (i.e., the length of <code>l</code> is not
a multiple of <code>num_cols</code>).
</p></li>
<li><p>
Euclid's algorithm for determining the greatest common divisor of
two integers is takes advantage of the fact that \(\mathsf{gcd}(m, n)
 = \mathsf{gcd}(n, m \bmod n)\).  Implement the function
</p>
<div class="org-src-container">
<pre class="src src-ocaml">let gcd (m : int) (n : int) : int =
  assert false (* TODO *)
</pre>
</div>
<p>
which, given two integers <code>m</code> and <code>n</code>, returns their greatest
commond divisor.
</p></li>
<li><p>
We represent a rational number as a pair of integers where the
first integer represents the numerator and the second represents
the denominator.  We maintain the invariant that the second number
is positive and the pair of numbers are relatively prime.
Implement the function <code>add</code> which adds two rational numbers,
making sure to maintain this invariant.
</p>
<div class="org-src-container">
<pre class="src src-ocaml">type rat = int * int

let add (m : rat) (n : rat) : rat =
  assert false (* TODO *)
</pre>
</div></li>
<li><p>
Implement the function
</p>
<div class="org-src-container">
<pre class="src src-ocaml">let gen_fib : (l : int list) (n : int) : int =
  if n &lt; 0
  then assert false
  else
    assert false (* TODO *)
</pre>
</div>
<p>
which, given a list of integers <code>l</code> of length \(k\) and a nonnegative
integer <code>n</code>, returns the <code>n</code>-th element of the following sequence:
</p>
\begin{equation*}
F_n =
\begin{cases}
l[n] & n < k \\
\sum_{i = 1}^k F_{n - i} & n \geq k
\end{cases}
\end{equation*}</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orge0d51e5" class="outline-3">
<h3 id="orge0d51e5">Algebraic Data Types</h3>
<div class="outline-text-3" id="text-orge0d51e5">
<p>
One of the most important features of a modern functional programming
language is pattern matching and algebraic data types.  An algebraic
data type (ADT) is defined by giving a collection of <b>constructors</b>,
which may themselves carry other data.  Here, for example, is an ADT
whose values represent either a Boolean values or an integers.
</p>
<div class="org-src-container">
<pre class="src src-ocaml">type bool_or_int
  = Bool of bool
  | Int of int
</pre>
</div>
<p>
We work with values of an ADT by <b>pattern matching</b>, providing
different values depending on the <i>shape</i> of the given value.
</p>
<div class="org-src-container">
<pre class="src src-ocaml">let num_val (x : bool_or_int) : int =
  match x with
  | Bool b -&gt; if b then 1 else 0
  | Int i -&gt; i
</pre>
</div>
<p>
ADTs can be <i>recursive</i> (the type being defined can be referred to in
the definition of the type) and <i>parametric</i> (the type being defined
can depend parametrically on another type).  These two features are encompassed in the <code>list</code> type.
</p>
<div class="org-src-container">
<pre class="src src-ocaml">type 'a mylist
  = Nil
  | Cons of 'a * 'a mylist
</pre>
</div>
</div>
<div id="outline-container-orgcaa61e5" class="outline-4">
<h4 id="orgcaa61e5">Exercises</h4>
</div>
</div>
<div id="outline-container-orgcedadcd" class="outline-3">
<h3 id="orgcedadcd">Record Types</h3>
<div class="outline-text-3" id="text-orgcedadcd">
<p>
Record types are essentially tuples with named fields.
</p>
<div class="org-src-container">
<pre class="src src-ocaml">type rat =
  { numer : int
  ; denom : int
  ; is_positive : bool
  }

let two_thirds =
  { numer = 2
  ; denom = 3
  ; is_positive = true
  }
</pre>
</div>
<p>
Beyond this, they have a couple conveniences that are good to remember.
</p>
<ul class="org-ul">
<li>Accessing fields in a record can be done via dot notation, i.e., if
<code>r</code> is a <code>rat</code> then <code>r.is_positive</code> is a <code>bool</code>.</li>
<li><p>
Updating a small number of fields records can be done using <code>with</code>-notation.
</p>
<div class="org-src-container">
<pre class="src src-ocaml">let negate (r : rat) : rat =
  { r with is_positive = not r.is_positive }

let recip (r : rat) : rat =
  if r.numer = 0
  then assert false
  else { r with numer = r.denom; denom = r.numer }
</pre>
</div></li>
</ul>
</div>
<div id="outline-container-orgee27efa" class="outline-4">
<h4 id="orgee27efa">Exercises</h4>
<div class="outline-text-4" id="text-orgee27efa">
<ol class="org-ol">
<li>merge user data</li>
<li>add to captured bindings</li>
<li>list of records to dictionary</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-org87ba4af" class="outline-3">
<h3 id="org87ba4af">Higher-Order Programming</h3>
<div class="outline-text-3" id="text-org87ba4af">
<p>
Higher-order programming is the use of functions as first-class values
to write general, reusable code.  There are three patterns in
particular for higher-order programming with lists which we looked at
in depth.
</p>
<ul class="org-ul">
<li><p>
The function <code>map</code>, defined as
</p>
<div class="org-src-container">
<pre class="src src-ocaml">let rec map (f : 'a -&gt; 'b) (l : 'a list) : 'b list =
  match l with
  | [] -&gt; []
  | x :: l -&gt; let x = f x in x :: map f l
</pre>
</div>
<p>
replaces each element in <code>l</code> with <code>f</code> applied to that element, in
order from left to right.
</p></li>
<li><p>
The function <code>filter</code>, defined as
</p>
<div class="org-src-container">
<pre class="src src-ocaml">let rec filter (p : 'a -&gt; bool) (l : 'a list) : 'a list =
  match l with
  | [] -&gt; []
  | x :: l -&gt; if p x then x :: filter p l else filter p l
</pre>
</div>
<p>
find all element of <code>l</code> which satisfy the predicate <code>p</code>, in order
from left to right.
</p></li>
<li><p>
The function <code>fold_right</code>, defined as
</p>
<div class="org-src-container">
<pre class="src src-ocaml">let rec fold_right (f : 'a -&gt; 'b -&gt; 'b) (l : 'a list) (accu : 'b) : 'b =
  match l with
  | [] -&gt; accu
  | x :: l -&gt; f x (fold_right f l accu)
</pre>
</div>
<p>
applies the binary operation <code>f</code> between every element of <code>l @ [accu]</code> right-associatively:
</p>
<pre class="example">
 [x1;   x2;   x3; ...   xn]
  ↓↓    ↓↓    ↓↓        ↓↓
f x1 (f x2 (f x3 (...(f xn accu)...)))
</pre>
<p>
The function <code>fold_left</code> does the same but to <code>accu :: l</code>  left-associatively:
</p>
<div class="org-src-container">
<pre class="src src-ocaml">let rec fold_left (f : 'b -&gt; 'a -&gt; 'b) (accu : 'b) (l : 'a list) : 'b =
  match l with
  | [] -&gt; accu
  | x :: l -&gt; fold_left f (f accu x) l
</pre>
</div>
<pre class="example">
                   [x1; x2; x3; ... xn]
                    ↓↓  ↓↓  ↓↓      ↓↓
f (...(f (f (f accu x1) x2) x3)...) xn
</pre></li>
</ul>
</div>
<div id="outline-container-orgdc8df56" class="outline-4">
<h4 id="orgdc8df56">Exercises</h4>
<div class="outline-text-4" id="text-orgdc8df56">
<ol class="org-ol">
<li>predicate operations</li>
<li>find the derivative (newtons)</li>
<li>radix sort bucketing as fold<sub>left</sub></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orgf62c214" class="outline-3">
<h3 id="orgf62c214">Tail Recursion</h3>
<div class="outline-text-3" id="text-orgf62c214">
<p>
Roughly speaking, a recursive call in the body of a function
definition is in <b>tail position</b> if no evaluation is required <i>after</i>
the recursive call.  The following implementation of the factorial
function is not tail recursive because it requires evaluating the
product of the result of its recursive call with the input <code>n</code>.
</p>
<div class="org-src-container">
<pre class="src src-ocaml">let rec factorial (n : int) : int =
  if n &lt; 0
  then assert false
  else if n = 0
  then 1
  else n * factorial n
</pre>
</div>
<p>
We tend to make functions tail recursive by adding an accumulator argument to the function.
</p>
<div class="org-src-container">
<pre class="src src-ocaml">let factorial_tail (n : int) : int =
  let rec go (n : int) (accu : int) =
    if n = 0
    then accu
    else go (n - 1) (n * accu)
  in
  if n &lt; 0
  then assert false
  else go n 1
</pre>
</div>
</div>
<div id="outline-container-orgbe45995" class="outline-4">
<h4 id="orgbe45995">Exercises</h4>
<div class="outline-text-4" id="text-orgbe45995">
<ol class="org-ol">
<li>hour glass + tr hour glass</li>
<li>tr evaluator</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org5863bf9" class="outline-3">
<h3 id="org5863bf9">Type Checking</h3>
<div class="outline-text-3" id="text-org5863bf9">
<p>
OCaml is strongly typed, and it is statically checked for adherence to
typing rules.  OCaml also has type inference, which means we often do
not have to specify the types of expressions in OCaml programs (though
it can be useful for documentation purposes).
</p>
</div>
<div id="outline-container-org99613af" class="outline-4">
<h4 id="org99613af">Exercises</h4>
<div class="outline-text-4" id="text-org99613af">
<ol class="org-ol">
<li>What is the type of this?</li>
<li>Does this type check?</li>
</ol>
</div>
</div>
</div>
</div>
<div id="outline-container-orge0e9d8a" class="outline-2">
<h2 id="orge0e9d8a">Formal Grammar</h2>
<div class="outline-text-2" id="text-orge0e9d8a">
<p>
In general, grammar is the study of the form structure of language.
We use concepts from the study of formal grammar to represent and
reason about the syntax of programming languages.  These concepts
inform the design of parsers.
</p>
</div>
<div id="outline-container-orgd39b698" class="outline-3">
<h3 id="orgd39b698">BNF Specifications</h3>
<div class="outline-text-3" id="text-orgd39b698">
<p>
We start with a collection of symbols, separated into to disjoint
groups, the <b>nonterminal</b> symbols and the <b>terminal</b> symbols.  In a
Backus-Naur Form (BNF) specification we use notation like <code>&lt;nonterm&gt;</code>
to denote a nonterminal symbols.  We typically don't specify the
symbols in advance, but instead glean then from the specification
itself.
</p>
</div>

<div id="outline-container-orgc50954e" class="outline-4">
<h4 id="orgc50954e">Definitions</h4>
<div class="outline-text-4" id="text-orgc50954e">
<p>
A <b>sentential form</b> is a sequences of symbols and a <b>sentence</b> is a
sequence of terminal symbols.
</p>

<p>
A <b>production rule</b> is made up of a nonterminal symbol and a
sentential form, and is written
</p>
<pre class="example">
&lt;nonterm&gt; ::= SENTFORM
</pre>
<p>
We interpret a production rule as indicating that <code>&lt;nonterm&gt;</code> <i>stands
for</i> <code>SENTFORM</code> in a sentence.
</p>

<p>
A <b>BNF specification</b> is given by a collection of production rules and
a <b>starting symbol</b>.  We typically take the nonterminal symbol in the
<i>first</i> rule of the specification to be the starting symbol.
</p>

<p>
A <b>derivation</b> of a sentential form \(S\) in a specification \(\mathcal
B\) with start symbol <code>&lt;start&gt;</code> is a sequence of sentential forms,
starting with the start symbol <code>&lt;start&gt;</code> and ending in \(S\), in which
each form in the sequence (except for <code>&lt;start&gt;</code>) is the results of
replacing a nonterminal symbol in the previous form with a sentential
from given by a production rule in \(\mathcal B\).
</p>

<p>
A derivation is <b>leftmost</b> if the nonterminal symbol replaced at each
step of the derivation is the leftmost nonterminal symbol in the
sentential form.
</p>

<p>
A <b>parse tree</b>, informally, is a derivation represented as a tree, in
which the root is labeled with the starting symbol and each node
contains as it's children the symbols of sentential form which it is
replaced with in the derivation. A parse tree may correspond to
multiple derivations, but every derivation has a unique parse tree
representation.
</p>
</div>
</div>

<div id="outline-container-orga7b93a9" class="outline-4">
<h4 id="orga7b93a9">Examples</h4>
<div class="outline-text-4" id="text-orga7b93a9">
<p>
TODO
</p>
</div>
</div>
<div id="outline-container-org028c409" class="outline-4">
<h4 id="org028c409">Exercises</h4>
<div class="outline-text-4" id="text-org028c409">
<ol class="org-ol">
<li>List the symbols implicit in this specification.</li>
<li>Give a derivation of S in this grammar.</li>
<li>Give a leftmost derivation of S in this grammar.</li>
<li>Give an example of a grammar with no leftmost derivations.</li>
<li>Draw the parse tree associated with this derivation.</li>
<li>Draw the parse tree for this sentence in this grammar.</li>
<li>Implement the algorithm which determines the sentence for a given
parse<sub>tree</sub>.</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org5fe2548" class="outline-3">
<h3 id="org5fe2548">Ambiguity</h3>
<div class="outline-text-3" id="text-org5fe2548">
<p>
A BNF specification is <b>ambiguous</b> if there is a sentence with
multiple parse trees.  We try to avoid ambiguous specifications for
programming languages because we don't want a program to be
interpretable in multiple ways.
</p>
</div>

<div id="outline-container-org26d040f" class="outline-4">
<h4 id="org26d040f">Fixity</h4>
<div class="outline-text-4" id="text-org26d040f">
<p>
The <b>fixity</b> of an operator refers to where the operator is written
with respect to its arguments.
</p>
<ul class="org-ul">
<li><b>prefix</b> operators appear <i>before</i> their argument
<ul class="org-ul">
<li>the negation operator: <code>-5</code></li>
</ul></li>
<li><b>postfix</b> operators appear <i>after</i> their argument
<ul class="org-ul">
<li>type constructors: <code>int list</code></li>
</ul></li>
<li><b>infix</b> (binary) operators appear <i>between</i> their arguments
<ul class="org-ul">
<li>arithmetic operators: <code>(1 + 2) * (3 + 4)</code>)</li>
</ul></li>
<li><b>mixfix</b> operators are a combination of these
<ul class="org-ul">
<li>if-else-expressions: <code>if not b the f x else g x</code></li>
</ul></li>
</ul>

<p>
One of the primary ways in which specifications of programming
languages can be ambiguous is in the use of infix and mixfix
operations.  If a language's syntactic constructs are all prefix
(Polish notation) or all postfix (reverse Polish notation) then the
specification is unambiguous.
</p>

<p>
We can make infix binary operators unambiguous by specifying their
associativity and precedence.
</p>
</div>
</div>
<div id="outline-container-org20af429" class="outline-4">
<h4 id="org20af429">Associativity</h4>
<div class="outline-text-4" id="text-org20af429">
<p>
An operator \(\square\) is declared <b>left associative</b> if we interpret
\(a \square b \square c\) to be equivalent to \((a \square b) \square c\).
</p>
<ul class="org-ul">
<li>For arithmetic expressions, we take subtraction to be
left-associative, so the expression <code>1 - 2 - 3</code> evaluates to <code>-4</code>
as opposed to <code>2</code>.</li>
</ul>

<p>
An operator \(\square\) is declared <b>right associative</b> if we interpret
\(a \square b \square c\) to be equivalent to \(a \square (b \square c)\).
</p>
<ul class="org-ul">
<li>For arithmetic expressions, we take exponentiation to be
right-associative, so the expression <code>2 ^ 1 ^ 3</code> evaluates to <code>2</code>
as opposed to <code>8</code>.</li>
</ul>

<p>
We can enforce the associativity of an operator in the specification itself.
</p>
</div>
</div>
<div id="outline-container-org4934e3c" class="outline-4">
<h4 id="org4934e3c">Precedence</h4>
<div class="outline-text-4" id="text-org4934e3c">
<p>
Given two binary operators \(\square\) and \(\triangle\), the operator
\(\square\) has <b>higher precedence</b> than \(\triangle\) if we interpret \(a
\square b \triangle c\) as \((a \square b) \triangle c\) and \(a \triangle
b \square c\) as \(a \triangle (b \square c)\).
</p>
<ul class="org-ul">
<li>For arithmetic expressions, we take multiplication to have higher
precedence than addition, so the expression <code>2 * 2 + 3</code> evaluates to
<code>7</code> as opposed to <code>10</code>.</li>
</ul>

<p>
As with associativity, we can enforce precedence within the
specification itself.
</p>

<p>
TODO
</p>
</div>
</div>
<div id="outline-container-org0adfa3c" class="outline-4">
<h4 id="org0adfa3c">Exercises</h4>
<div class="outline-text-4" id="text-org0adfa3c">
<ol class="org-ol">
<li>Is this grammar ambiguous?</li>
<li>Find a sentence in this grammar which has multiple derivations.</li>
<li>Update this grammar so that it makes the operations precedence and hold</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org19c5b81" class="outline-3">
<h3 id="org19c5b81">Regular Grammars</h3>
<div class="outline-text-3" id="text-org19c5b81">
<p>
Regular grammars are a special form of grammar.
</p>

<p>
Regular expressions are a compact representation of regular grammars.
</p>
</div>
</div>
<div id="outline-container-org5dd135d" class="outline-3">
<h3 id="org5dd135d">Chomsky Norm Form</h3>
<div class="outline-text-3" id="text-org5dd135d">
<p>
TODO
</p>
</div>
</div>
</div>
<div id="outline-container-org6a3f72d" class="outline-2">
<h2 id="org6a3f72d">Parsing</h2>
<div class="outline-text-2" id="text-org6a3f72d">
<p>
The general parsing problem is to find a derivation of a sentence, if
one exists.  (NOTE ON CHOMSKY)
</p>

<p>
In the context of this course, we are more interested in the specific
problem of converting a string representation of a program into an
algebraic data type representing the syntax of the program.
</p>

<p>
There are many ways to accomplish this, we saw two.
</p>
</div>

<div id="outline-container-org9664a00" class="outline-3">
<h3 id="org9664a00">Recursive-Descent</h3>
<div class="outline-text-3" id="text-org9664a00">
<p>
Recursive-descent parsing refers to an ad-hoc form of parsing in which
mutually recursive functions are defined to parse forms of a
specification.
</p>

<p>
This is best understood by example.
</p>

<p>
TODO
</p>

<p>
(Note: It is unlikely that recursive-descent parsing will appear on
the final exam in any significant way.)
</p>
</div>
</div>

<div id="outline-container-orgf8e306b" class="outline-3">
<h3 id="orgf8e306b">Combinators</h3>
<div class="outline-text-3" id="text-orgf8e306b">
<p>
We can think of a parser for <code>'a</code>'s as a functions of type
</p>
<div class="org-src-container">
<pre class="src src-ocaml">type 'a parser = char list -&gt; ('a * char list) option
</pre>
</div>
<p>
which
</p>
<ol class="org-ol">
<li>consumes the prefix of the input stream corresponding to an <code>'a</code>,</li>
<li>converts that prefix to an <code>'a</code>, and finally,</li>
<li>returns that <code>'a</code> and the remainder of the stream, failing if no
initial part of the stream corresponds to an <code>'a</code>.</li>
</ol>

<p>
One of the simplest examples is the <code>char</code> parser:
</p>
<div class="org-src-container">
<pre class="src src-ocaml">let char (d : char) (cs : char list) : (char * char list) option =
  match cs with
  | c :: cs when c = d -&gt; Some (d, cs)
  | _ -&gt; None
</pre>
</div>
<p>
which consumes the first character of <code>cs</code> given that it is equal to
<code>d</code> and returns it, along with the remainder of <code>cs</code>.  This parser
fails (returns <code>None</code>) in the case that the first character of <code>cs</code> is
not <code>d</code>.
</p>

<p>
When we want to <i>use</i> a parser, we apply it to a character list and
verify that it consumed it's the entire input:
</p>
<div class="org-src-container">
<pre class="src src-ocaml">let parse (p : 'a parser) (s : string) =
  match p (explode s) with
  | (a, []) -&gt; Some a
  | _ -&gt; None
</pre>
</div>

<p>
A <b>parser combinator</b> is a higher-order function which can be used to
compose parsers. There is a small subset of parser combinators which
are of particular importance because they correspond to the constructs
in EBNF specifications.
</p>
<ul class="org-ul">
<li><p>
<b>Alternatives.</b> <code>p1 &lt;|&gt; p2</code> is the parser which tries running the
parser <code>p1</code>, returning its output if it succeeds, and running <code>p2</code>
otherwise.
</p>

<p>
If <code>p1</code> is a parser for the forms of a nonterminal symbol <code>&lt;p1&gt;</code>
and <code>p2</code> a parser for forms of a nonterminal symbol <code>&lt;p2&gt;</code>, then <code>p1
  &lt;|&gt; p2</code> is a parser for forms of the nonterminal symbol
</p>
<pre class="example">
&lt;alt&gt; ::= &lt;p1&gt; | &lt;p2&gt;
</pre></li>
<li><p>
<b>Sequencing.</b> <code>seq p1 p2</code> is the parser which runs both <code>p1</code> and
<code>p2</code> and returns both of their outputs if both parsers succeed.  It
fails if either <code>p1</code> or <code>p2</code> fails.
</p>

<p>
If <code>p1</code> is a parser for the forms of a nonterminal symbol <code>&lt;p1&gt;</code> and
<code>p2</code> a parser for forms of a nonterminal symbol <code>&lt;p2&gt;</code>, then <code>p1 &lt;|&gt;
  p2</code> is a parser for forms of the nonterminal symbol
</p>
<pre class="example">
&lt;seq&gt; ::= &lt;p1&gt; &lt;p2&gt;
</pre></li>
<li><p>
<b>Repetition.</b> <code>many p</code> is the parser which runs <code>p</code> repeatedly until
it fails, collecting all its outputs in a list.
</p>

<p>
If <code>p</code> is a parser for the forms of a nonterminal symbol <code>&lt;p&gt;</code> and
<code>p2</code> a parser for forms of a nonterminal symbol <code>&lt;p2&gt;</code>, then <code>many
  p</code> is a parser for forms of the nonterminal symbol
</p>
<pre class="example">
&lt;many&gt; ::= { &lt;p&gt; }
</pre></li>
</ul>

<p>
The last important combinator is <code>map</code>, which can be used to
manipulate the output of a parser without affecting how it consumes
its input.  If <code>p</code> is an <code>'a parser</code>, and <code>f</code> is a function of type
<code>'a -&gt; 'b</code>, then <code>map f p</code> is a <code>'b parser</code> which runs <code>'a</code> and then
applies <code>f</code> to its output (if it succeeds).
</p>

<p>
You should also be familiar with how to use the more convenient parser
combinators throughout the course (though, for the exam, you will not
be required to memorize their definitions).
</p>
<ul class="org-ul">
<li><code>str</code>, <code>token</code>, <code>ws</code></li>
<li>(<code>&gt;&gt;</code>), (<code>&lt;&lt;</code>), <code>seq3</code>, <code>seq4</code></li>
<li>(<code>&gt;|</code>), <code>map2</code>, <code>map3</code>, <code>map4</code></li>
<li><code>pure</code>, <code>fail</code>, (we will not test on <code>bind</code> (<code>&gt;&gt;=</code>) but it is good to know&#x2026;)</li>
</ul>
</div>


<div id="outline-container-org0218e89" class="outline-4">
<h4 id="org0218e89">Exercises</h4>
</div>
</div>
</div>
<div id="outline-container-orga0ae140" class="outline-2">
<h2 id="orga0ae140">Formal Semantics</h2>
<div class="outline-text-2" id="text-orga0ae140">
<p>
In general, semantics is the study of the <i>meaning</i> of language.  We
use concepts from the study of formal semantics to model the behavior
(i.e., the meaning) of programs.
</p>

<p>
We discussed two forms of semantics, <b>denotational</b> semantics and
<b>operational</b> semantics.
</p>

<p>
Giving a denotational semantics for a programming language means
assigning to each a <i>mathematical function</i> which has the same
input/output behavior as the program.
</p>

<p>
In this course, we focus on operational semantics.  Giving an
operational semantics for a programming language means describing how
a program in the language is evaluated.  This typically means defining
a <b>reduction relation</b> on programs, which describes how a program is
reduced until it reaches a state which cannot be further reduced.
</p>
</div>

<div id="outline-container-org86d466c" class="outline-3">
<h3 id="org86d466c">Derivations</h3>
<div class="outline-text-3" id="text-org86d466c">
<p>
Suppose we have a programming language \(\mathcal P\) defined by a given BNF grammar.
</p>

<p>
A <b>configuration</b> is a pair consistent of a program \(P\) and a state
\(S\) which may be manipulated by programs.  The state may be empty, as
in the case of functional languages.
</p>

<p>
Defining the (small-step) operational semantics for \(\mathcal P\) means
defining a reduction relation for configurations:
</p>
\begin{equation*}
( \ S \ , \ P \ ) \longrightarrow ( \ S' \ , \ P' \ )
\end{equation*}

<p>
A reduction relation is typically defined via <b>reduction rules</b>, which
consist of a <i>shape</i> of a reduction together with a collection of
<b>premises</b>, which may be shapes of reductions or trivial premises
(also called axioms). The general form of a reduction rules is
something like
</p>
\begin{equation*}
\frac
{P_1 \qquad P_2 \qquad \dots \qquad P_k}
{C \longrightarrow C'}
\ \textsf{(name)}
\end{equation*}

<p>
<i>Shape</i> here refers to the fact that the configurations in a reduction
rule contains <i>meta-variables</i> that describe the <i>kind of reductions</i>
that can be derived, or that can be used a premises.  For example, the
rules for evaluating an arithmetic expression might include
</p>
\begin{equation*}
\frac{e_1 \longrightarrow e_1'}
{e_1 + e_2 \longrightarrow e_1' + e_2}
\ \textsf{(add-left)}
\end{equation*}
<p>
which expresses that if \(e_1\) reduces to \(e_1'\) in a single step then
\(e_1 + e_2\) reduces to \(e_1 + e_2'\) in a single step <i>no matter the
expressions \(e_1\), \(e_1'\) and \(e_2\)</i>.  This rule can be used to show that
</p>
\begin{equation*}
(1 + 2) + 3 \longrightarrow 3 + 3
\end{equation*}
<p>
but also that
</p>
\begin{equation*}
(1 + (2 * 3)) + 3 \longrightarrow (1 + 6) + 3
\end{equation*}
<p>
Both reductions invoke that fact that if the left argument can be
reduced by a single step, then the sum can be reduced by a single
step.
</p>

<p>
A <b>derivation</b> is, informally, a tree in which each node is a
reduction and the children of a node are the premises required to
derive that conclusion.  The leaves of a derivation are trivial
premises (axioms).
</p>

<p>
A derivation of a reduction \(C \longrightarrow C'\) is a derivation
whose root is \(C \longrightarrow C'\).
</p>

<p>
TODO derivation
</p>

<p>
It is generally preferable that any derivable reduction has a unique
derivation.  This defining an evaluation procedure easier, and amounts
to fixing an <b>evaluation order</b>.  We can often enforce an evaluation
order via the structure of our reduction rules.
</p>

<p>
What we have been describing is a <b>single-step reduction relation</b>.
Any single-step reduction relation can be extended to a <b>multi-step
reduction relation</b> by including the following rules and a multi-step reduction relation symbol
'\(\longrightarrow^{\star}\)'.
</p>
\begin{equation*}
\frac
{}
{C \longrightarrow^\star C}
\ \textsf{(refl)}
\qquad
\frac
{C \longrightarrow^\star C' \qquad C' \longrightarrow C''}
{C \longrightarrow^\star C''}
\ \textsf{(trans)}
\end{equation*}

<p>
Formally, <b>evaluation</b> is the process of determining a configuration \(C'\) for a
given configuration \(C\) such that \(C \longrightarrow^\star C'\) and
\(C'\) cannot be further reduced (i.e., there is no other configuration
\(C''\) such that \(C' \longrightarrow C''\)).
</p>
</div>

<div id="outline-container-org638c6ba" class="outline-4">
<h4 id="org638c6ba">Exercises</h4>
<div class="outline-text-4" id="text-org638c6ba">
<ol class="org-ol">
<li>Write a derivation for this reduction.</li>
<li>Find a configuration which this single-step reduces to.</li>
<li>Write a derivation for this multi-step reduction.</li>
<li>Find a configuration for this multi-step reduction.</li>
<li>Show that this reduction relation is not normalizing.</li>
<li>Show that this relation is not unique.</li>
<li>Make this reduction update the above relation so that it has unique
reductions and arguments are evaluated from left to right.</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orgc963db8" class="outline-3">
<h3 id="orgc963db8">Examples</h3>
<div class="outline-text-3" id="text-orgc963db8">
</div>
<div id="outline-container-org0a342ac" class="outline-4">
<h4 id="org0a342ac">Arithmetic Expressions</h4>
</div>
<div id="outline-container-org1bc4654" class="outline-4">
<h4 id="org1bc4654">The Lambda Calculus</h4>
</div>
<div id="outline-container-orgecfa776" class="outline-4">
<h4 id="orgecfa776">A Stack-Oriented Language</h4>
<div class="outline-text-4" id="text-orgecfa776">
<p>
One of the running examples we used for understanding operations
semantics was stack-oriented languages.
</p>

<p>
The following is a BNF specification for a stack-oriented language
whose programs manipulate a stack of integers.
</p>
<pre class="example">
&lt;prog&gt;  ::= { &lt;com&gt; }
&lt;com&gt;   ::= &lt;num&gt; | drop | dup | swap | .
          | + | - | *
          | then &lt;com&gt; else &lt;com&gt; end
&lt;num&gt;   ::= &lt;digit&gt; { &lt;digit&gt; }
&lt;digit&gt; ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
</pre>

<p>
Here, for example, is a program which determines the prints the value of \(14^2 + 15^2\).
</p>
<pre class="example">
14 dup *
15 dup *
+ .
</pre>
<p>
In the operational semantics of this language we take a configuration
to be a program (\(P\)) together with a stack of integers (\(S\)) and a trace of
strings (\(T\)) that are printed throughout the evaluation of the program.
</p>
\begin{equation*}
( \ S \ , \ T \ , \ P \ )
\end{equation*}
<p>
with a special error configuration
</p>
\begin{equation*}
\mathsf{ERROR} \equiv ( \ \varnothing \ , \ \textsf{panic} :: \varnothing \ , \ \epsilon \ )
\end{equation*}

<p>
The operational semantics then describe how each command affects the stack and the trace.
</p>

<p>
TODO
</p>
</div>
</div>
<div id="outline-container-org1767273" class="outline-4">
<h4 id="org1767273">Exercises</h4>
<div class="outline-text-4" id="text-org1767273">
<p>
TODO
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgd08fbca" class="outline-2">
<h2 id="orgd08fbca">Subroutines</h2>
<div class="outline-text-2" id="text-orgd08fbca">
</div>
<div id="outline-container-org599e14b" class="outline-3">
<h3 id="org599e14b">Parameter Passing</h3>
</div>
<div id="outline-container-org186cdf4" class="outline-3">
<h3 id="org186cdf4">Examples</h3>
<div class="outline-text-3" id="text-org186cdf4">
</div>
<div id="outline-container-org02aa012" class="outline-4">
<h4 id="org02aa012">Lambda Calculus with Call-by-Name Operational Semantics</h4>
</div>
<div id="outline-container-org0f59e61" class="outline-4">
<h4 id="org0f59e61">Lambda Calculus with Call-by-Value Operational Semantics</h4>
</div>
<div id="outline-container-org90cc27f" class="outline-4">
<h4 id="org90cc27f">Stack-Oriented Language with Subroutines</h4>
</div>
</div>
</div>
<div id="outline-container-org2552d76" class="outline-2">
<h2 id="org2552d76">Environments</h2>
<div class="outline-text-2" id="text-org2552d76">
<p>
We need to specify how those variable bindings are represented in a
configuration.
</p>

<p>
When introducing variables to a programming language, we have to
specify when/where those bindings are accessible. This is called the
<b>scope</b> of the binding.  In general, this is a complex question, but
is broad strokes there are two paradigms: <b>dynamic scoping</b> and
<b>lexical scoping</b>.
</p>
</div>
<div id="outline-container-org97147b3" class="outline-3">
<h3 id="org97147b3">Stack-Oriented Language with Variables</h3>
</div>
</div>
<div id="outline-container-orge83cf98" class="outline-2">
<h2 id="orge83cf98">Dynamic Scoping</h2>
<div class="outline-text-2" id="text-orge83cf98">
<p>
Dynamic scoping refers to the idea of using <i>computational (temporal)
context</i> to determine when a binding is available.  In its simplest
form, we may think of all bindings as globally available as soon as
they have been instantiated.
</p>

<p>
In a language with dynamic scoping and <i>subroutines</i>, when it comes to
determining what bindings are available, it doesn't matter where a
subroutine is defined, but rather where it is called.
</p>

<p>
Bash is a widely used language with dynamic scoping, but in general,
dynamic scoping is not common in modern programming languages.  It is,
however, much easier to implement than lexical scoping.
</p>
</div>
<div id="outline-container-org629ca0b" class="outline-3">
<h3 id="org629ca0b">Stack-Oriented Language with Dynamic Scoping</h3>
</div>
</div>
<div id="outline-container-orgbc1fe25" class="outline-2">
<h2 id="orgbc1fe25">Lexical Scoping</h2>
<div class="outline-text-2" id="text-orgbc1fe25">
</div>
<div id="outline-container-orgf4a1425" class="outline-3">
<h3 id="orgf4a1425">Activation Records</h3>
<div class="outline-text-3" id="text-orgf4a1425">
</div>
<div id="outline-container-org7384464" class="outline-4">
<h4 id="org7384464">Stack-Oriented Language with Mutable Variables and Lexical Scoping</h4>
</div>
</div>
<div id="outline-container-org6e9edfe" class="outline-3">
<h3 id="org6e9edfe">Closures</h3>
<div class="outline-text-3" id="text-org6e9edfe">
</div>
<div id="outline-container-orgc60e210" class="outline-4">
<h4 id="orgc60e210">Stack-Oriented Language with Immutable Variables and Lexical Scoping</h4>
</div>
</div>
</div>
<div id="outline-container-org6047722" class="outline-2">
<h2 id="org6047722">Compilation</h2>
</div>
<div id="outline-container-org54d3a2a" class="outline-2">
<h2 id="org54d3a2a">Solutions to Exercises</h2>
</div>
</div>
</body>
</html>
